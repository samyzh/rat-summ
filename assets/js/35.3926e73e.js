(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{1608:function(v,_,t){v.exports=t.p+"assets/img/10d6d8e9f6c8456bb0f9d15e1ed15b5atplv-k3u1fbpfcp-zoom-1.e9eccb04.png"},1609:function(v,_,t){v.exports=t.p+"assets/img/a2405aff906648f5b261e9ac1b649cb5tplv-k3u1fbpfcp-zoom-1.f797ca6a.png"},1610:function(v,_,t){v.exports=t.p+"assets/img/cbd86057193544b3ad2ad1f423e23beatplv-k3u1fbpfcp-zoom-1.cb693301.png"},1611:function(v,_,t){v.exports=t.p+"assets/img/0c73f71028fb4480bf9b27cf5ea8026dtplv-k3u1fbpfcp-zoom-1.6c38e63f.png"},1612:function(v,_,t){v.exports=t.p+"assets/img/79ac497722f5458e839dc4f939540323tplv-k3u1fbpfcp-zoom-1.488aee2c.png"},1613:function(v,_,t){v.exports=t.p+"assets/img/06f28dcc37e0472db86c86fe0d735837tplv-k3u1fbpfcp-zoom-1.45778afb.png"},1614:function(v,_,t){v.exports=t.p+"assets/img/d943857a2d0e4ba0b14a8079222d4933tplv-k3u1fbpfcp-zoom-1.3d477e8f.png"},1615:function(v,_,t){v.exports=t.p+"assets/img/554e188bd932480d92dbe76250f87d54tplv-k3u1fbpfcp-zoom-1.dc431ace.png"},1616:function(v,_,t){v.exports=t.p+"assets/img/48af9b0e7bd04ea5a101b987c909fbe2tplv-k3u1fbpfcp-zoom-1.c4c14b8a.png"},1617:function(v,_,t){v.exports=t.p+"assets/img/cf9ee1ef58bb4c7d992bb44231cbe420tplv-k3u1fbpfcp-zoom-1.4ce7fb38.png"},1618:function(v,_,t){v.exports=t.p+"assets/img/16484133eee33c76.a40cef21.png"},2271:function(v,_,t){"use strict";t.r(_);var s=t(14),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h2",{attrs:{id:"网络模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络模型"}},[v._v("#")]),v._v(" 网络模型")]),v._v(" "),s("h3",{attrs:{id:"osi七层模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#osi七层模型"}},[v._v("#")]),v._v(" OSI七层模型")]),v._v(" "),s("p",[s("code",[v._v("ISO")]),v._v("为了更好的使网络应用更为普及，推出了"),s("code",[v._v("OSI")]),v._v("参考模型。 "),s("img",{attrs:{src:t(1608),alt:"img"}})]),v._v(" "),s("h4",{attrs:{id:"应用层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用层"}},[v._v("#")]),v._v(" 应用层")]),v._v(" "),s("p",[s("code",[v._v("OSI")]),v._v("参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有："),s("code",[v._v("HTTP")]),v._v("，"),s("code",[v._v("HTTPS")]),v._v("，"),s("code",[v._v("FTP")]),v._v("，"),s("code",[v._v("POP3")]),v._v("、"),s("code",[v._v("SMTP")]),v._v("等。")]),v._v(" "),s("ul",[s("li",[v._v("在客户端与服务器中经常会有数据的请求，这个时候就是会用到"),s("code",[v._v("http(hyper text transfer protocol)(超文本传输协议)")]),v._v("或者"),s("code",[v._v("https")]),v._v(".在后端设计数据接口时，我们常常使用到这个协议。")]),v._v(" "),s("li",[s("code",[v._v("FTP")]),v._v("是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如"),s("code",[v._v("百度网盘``迅雷")]),v._v("应该是基于此协议的。")]),v._v(" "),s("li",[s("code",[v._v("SMTP")]),v._v("是"),s("code",[v._v("simple mail transfer protocol（简单邮件传输协议）")]),v._v("。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。")])]),v._v(" "),s("h4",{attrs:{id:"表示层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#表示层"}},[v._v("#")]),v._v(" 表示层")]),v._v(" "),s("p",[v._v("表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。")]),v._v(" "),s("p",[v._v("在项目开发中，为了方便数据传输，可以使用"),s("code",[v._v("base64")]),v._v("对数据进行编解码。如果按功能来划分，"),s("code",[v._v("base64")]),v._v("应该是工作在表示层。")]),v._v(" "),s("h4",{attrs:{id:"会话层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#会话层"}},[v._v("#")]),v._v(" 会话层")]),v._v(" "),s("p",[v._v("会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。")]),v._v(" "),s("h4",{attrs:{id:"传输层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#传输层"}},[v._v("#")]),v._v(" 传输层")]),v._v(" "),s("p",[v._v("传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，"),s("code",[v._v("TCP")]),v._v(" "),s("code",[v._v("UDP")]),v._v("就是在这一层。端口号既是这里的“端”。")]),v._v(" "),s("h4",{attrs:{id:"网络层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络层"}},[v._v("#")]),v._v(" 网络层")]),v._v(" "),s("p",[v._v("本层通过"),s("code",[v._v("IP")]),v._v("寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的"),s("code",[v._v("IP")]),v._v("层。这一层就是我们经常说的"),s("code",[v._v("IP")]),v._v("协议层。"),s("code",[v._v("IP")]),v._v("协议是"),s("code",[v._v("Internet")]),v._v("的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。")]),v._v(" "),s("h4",{attrs:{id:"数据链路层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据链路层"}},[v._v("#")]),v._v(" 数据链路层")]),v._v(" "),s("p",[v._v("将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。 网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。")]),v._v(" "),s("h4",{attrs:{id:"物理层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#物理层"}},[v._v("#")]),v._v(" 物理层")]),v._v(" "),s("p",[v._v("实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。")]),v._v(" "),s("p",[s("strong",[v._v("OSI七层模型通信特点：对等通信")]),v._v(" 对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。")]),v._v(" "),s("h3",{attrs:{id:"tcp-ip五层协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip五层协议"}},[v._v("#")]),v._v(" TCP/IP五层协议")]),v._v(" "),s("p",[s("code",[v._v("TCP/IP")]),v._v("五层协议和"),s("code",[v._v("OSI")]),v._v("的七层协议对应关系如下： "),s("img",{attrs:{src:t(1609),alt:"img"}})]),v._v(" "),s("ul",[s("li",[s("p",[s("strong",[v._v("应用层 (application layer)")]),v._v("：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。")])]),v._v(" "),s("li",[s("p",[v._v("传输层 (transport layer)")]),v._v(" "),s("p",[v._v("：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：")]),v._v(" "),s("ul",[s("li",[v._v("传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；")]),v._v(" "),s("li",[v._v("用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。")])])]),v._v(" "),s("li",[s("p",[s("strong",[v._v("网络层 (internet layer)")]),v._v("：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。")])]),v._v(" "),s("li",[s("p",[s("strong",[v._v("数据链路层 (data link layer)")]),v._v("：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。")])]),v._v(" "),s("li",[s("p",[s("strong",[v._v("物理层 (physical Layer)")]),v._v("：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。")])])]),v._v(" "),s("p",[v._v("从上面的图中，我们可以看出，"),s("code",[v._v("TCP/IP")]),v._v("模型比"),s("code",[v._v("OSI")]),v._v("模型更加简洁，它把"),s("code",[v._v("应用层/表示层/会话层")]),v._v("全部整合为了"),s("code",[v._v("应用层")]),v._v("。 在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。 "),s("img",{attrs:{src:t(1610),alt:"img"}}),v._v(" 在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的协议： "),s("img",{attrs:{src:t(1611),alt:"img"}})]),v._v(" "),s("p",[v._v("同样，"),s("code",[v._v("TCP/IP")]),v._v("五层协议的通信方式也是对等通信： "),s("img",{attrs:{src:t(1612),alt:"image.png"}})]),v._v(" "),s("h2",{attrs:{id:"tcp与udp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp"}},[v._v("#")]),v._v(" TCP与UDP")]),v._v(" "),s("h3",{attrs:{id:"tcp-和-udp的概念及特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-和-udp的概念及特点"}},[v._v("#")]),v._v(" TCP 和 UDP的概念及特点")]),v._v(" "),s("p",[v._v("TCP 和 UDP都是传输层协议，他们都属于TCP/IP协议族：")]),v._v(" "),s("p",[s("strong",[v._v("（1）UDP")]),v._v(" UDP的全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。")]),v._v(" "),s("p",[v._v("它有以下几个特点：")]),v._v(" "),s("p",[s("strong",[v._v("1）面向无连接")]),v._v(" 首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。 具体来说就是：")]),v._v(" "),s("ul",[s("li",[v._v("在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了")]),v._v(" "),s("li",[v._v("在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作")])]),v._v(" "),s("p",[s("strong",[v._v("2）有单播，多播，广播的功能")]),v._v(" UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。")]),v._v(" "),s("p",[s("strong",[v._v("3）UDP是面向报文的")]),v._v(" 发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文")]),v._v(" "),s("p",[s("strong",[v._v("4）不可靠性")]),v._v(" 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。")]),v._v(" "),s("p",[v._v("再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。")]),v._v(" "),s("p",[s("strong",[v._v("5）头部开销小，传输数据报文时是很高效的。")]),v._v(" "),s("img",{attrs:{src:t(1613),alt:"img"}}),v._v(" UDP 头部包含了以下几个数据：")]),v._v(" "),s("ul",[s("li",[v._v("两个十六位的端口号，分别为源端口（可选字段）和目标端口")]),v._v(" "),s("li",[v._v("整个数据报文的长度")]),v._v(" "),s("li",[v._v("整个数据报文的检验和（IPv4 可选 字段），该字段用于发现头部信息和数据中的错误")])]),v._v(" "),s("p",[v._v("因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的")]),v._v(" "),s("p",[s("strong",[v._v("（2）TCP")])]),v._v(" "),s("p",[v._v("TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构。")]),v._v(" "),s("p",[v._v("它有以下几个特点：")]),v._v(" "),s("p",[s("strong",[v._v("1）面向连接")]),v._v(" 面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。")]),v._v(" "),s("p",[s("strong",[v._v("2）仅支持单播传输")]),v._v(" 每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。")]),v._v(" "),s("p",[s("strong",[v._v("3）面向字节流")]),v._v(" TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。")]),v._v(" "),s("p",[s("strong",[v._v("4）可靠传输")]),v._v(" 对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。")]),v._v(" "),s("p",[s("strong",[v._v("5）提供拥塞控制")]),v._v(" 当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞")]),v._v(" "),s("p",[s("strong",[v._v("6）提供全双工通信")]),v._v(" TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）")]),v._v(" "),s("h3",{attrs:{id:"tcp和udp的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别"}},[v._v("#")]),v._v(" TCP和UDP的区别")]),v._v(" "),s("table",[s("thead",[s("tr",[s("th"),v._v(" "),s("th",[v._v("UDP")]),v._v(" "),s("th",[v._v("TCP")])])]),v._v(" "),s("tbody",[s("tr",[s("td",[v._v("是否连接")]),v._v(" "),s("td",[v._v("无连接")]),v._v(" "),s("td",[v._v("面向连接")])]),v._v(" "),s("tr",[s("td",[v._v("是否可靠")]),v._v(" "),s("td",[v._v("不可靠传输，不使用流量控制和拥塞控制")]),v._v(" "),s("td",[v._v("可靠传输（数据顺序和正确性），使用流量控制和拥塞控制")])]),v._v(" "),s("tr",[s("td",[v._v("连接对象个数")]),v._v(" "),s("td",[v._v("支持一对一，一对多，多对一和多对多交互通信")]),v._v(" "),s("td",[v._v("只能是一对一通信")])]),v._v(" "),s("tr",[s("td",[v._v("传输方式")]),v._v(" "),s("td",[v._v("面向报文")]),v._v(" "),s("td",[v._v("面向字节流")])]),v._v(" "),s("tr",[s("td",[v._v("首部开销")]),v._v(" "),s("td",[v._v("首部开销小，仅8字节")]),v._v(" "),s("td",[v._v("首部最小20字节，最大60字节")])]),v._v(" "),s("tr",[s("td",[v._v("适用场景")]),v._v(" "),s("td",[v._v("适用于实时应用（IP电话、视频会议、直播等）")]),v._v(" "),s("td",[v._v("适用于要求可靠传输的应用，例如文件传输")])])])]),v._v(" "),s("h3",{attrs:{id:"tcp和udp的使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的使用场景"}},[v._v("#")]),v._v(" TCP和UDP的使用场景")]),v._v(" "),s("p",[s("strong",[v._v("TCP应用场景：")]),v._v(" 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。")]),v._v(" "),s("p",[s("strong",[v._v("UDP应用场景：")]),v._v(" 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。")]),v._v(" "),s("h3",{attrs:{id:"udp协议为什么不可靠"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#udp协议为什么不可靠"}},[v._v("#")]),v._v(" UDP协议为什么不可靠？")]),v._v(" "),s("p",[v._v("UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：")]),v._v(" "),s("ul",[s("li",[v._v("不保证消息交付：不确认，不重传，无超时")]),v._v(" "),s("li",[v._v("不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞")]),v._v(" "),s("li",[v._v("不跟踪连接状态： 不必建立连接或重启状态机")]),v._v(" "),s("li",[v._v("不进行拥塞控制： 不内置客户端或网络反馈机制")])]),v._v(" "),s("h3",{attrs:{id:"tcp的重传机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp的重传机制"}},[v._v("#")]),v._v(" TCP的重传机制")]),v._v(" "),s("p",[v._v("由于TCP的下层网络（网络层）可能出现"),s("strong",[v._v("丢失、重复或失序")]),v._v("的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是"),s("strong",[v._v("基于时间")]),v._v("，二是"),s("strong",[v._v("基于确认信息")]),v._v("。")]),v._v(" "),s("p",[v._v("TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。")]),v._v(" "),s("h3",{attrs:{id:"tcp的拥塞控制机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp的拥塞控制机制"}},[v._v("#")]),v._v(" TCP的拥塞控制机制")]),v._v(" "),s("p",[v._v("TCP的拥塞控制机制主要是以下四种机制：")]),v._v(" "),s("ul",[s("li",[v._v("慢启动（慢开始）")]),v._v(" "),s("li",[v._v("拥塞避免")]),v._v(" "),s("li",[v._v("快速重传")]),v._v(" "),s("li",[v._v("快速恢复")])]),v._v(" "),s("p",[s("strong",[v._v("（1）慢启动（慢开始）")])]),v._v(" "),s("ul",[s("li",[v._v("在开始发送的时候设置cwnd = 1（cwnd指的是拥塞窗口）")]),v._v(" "),s("li",[v._v("思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。")]),v._v(" "),s("li",[v._v("为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)\n"),s("ul",[s("li",[v._v("当cnwd < ssthresh，使用慢开始算法")]),v._v(" "),s("li",[v._v("当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法")]),v._v(" "),s("li",[v._v("当cnwd > ssthresh，使用拥塞避免算法")])])])]),v._v(" "),s("p",[s("strong",[v._v("（2）拥塞避免")])]),v._v(" "),s("ul",[s("li",[v._v("拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。")]),v._v(" "),s("li",[v._v("思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一")]),v._v(" "),s("li",[v._v("无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示: "),s("img",{attrs:{src:t(1614),alt:"img"}}),v._v(" 其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。")])]),v._v(" "),s("p",[s("strong",[v._v("（3）快速重传")])]),v._v(" "),s("ul",[s("li",[v._v("快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。快重传算法规定，发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。")]),v._v(" "),s("li",[v._v("由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量")])]),v._v(" "),s("p",[s("strong",[v._v("（4） 快速恢复")])]),v._v(" "),s("ul",[s("li",[v._v("当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。")]),v._v(" "),s("li",[v._v("考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。 "),s("img",{attrs:{src:t(1615),alt:"img"}})])]),v._v(" "),s("h3",{attrs:{id:"tcp的流量控制机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp的流量控制机制"}},[v._v("#")]),v._v(" TCP的流量控制机制")]),v._v(" "),s("p",[v._v("一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。 TCP采用大小可变的"),s("strong",[v._v("滑动窗口")]),v._v("进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输几个数据。")]),v._v(" "),s("ul",[s("li",[v._v("当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。")]),v._v(" "),s("li",[v._v("当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）")]),v._v(" "),s("li",[v._v("如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。")]),v._v(" "),s("li",[v._v("如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。")])]),v._v(" "),s("h3",{attrs:{id:"tcp的可靠传输机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp的可靠传输机制"}},[v._v("#")]),v._v(" TCP的可靠传输机制")]),v._v(" "),s("p",[v._v("TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。")]),v._v(" "),s("p",[v._v("TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。")]),v._v(" "),s("p",[v._v("接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。")]),v._v(" "),s("p",[v._v("发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。")]),v._v(" "),s("p",[v._v("但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。")]),v._v(" "),s("h3",{attrs:{id:"tcp的三次握手和四次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp的三次握手和四次挥手"}},[v._v("#")]),v._v(" TCP的三次握手和四次挥手")]),v._v(" "),s("h4",{attrs:{id:"三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[v._v("#")]),v._v(" 三次握手")]),v._v(" "),s("p",[s("img",{attrs:{src:t(1616),alt:"img"}}),v._v(" 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。 刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。")]),v._v(" "),s("ul",[s("li",[v._v("第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。")])]),v._v(" "),s("blockquote",[s("p",[v._v("首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。")])]),v._v(" "),s("ul",[s("li",[v._v("第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。")])]),v._v(" "),s("blockquote",[s("p",[v._v("在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y")])]),v._v(" "),s("ul",[s("li",[v._v("第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。")])]),v._v(" "),s("blockquote",[s("p",[v._v("确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。")])]),v._v(" "),s("p",[s("strong",[v._v("那为什么要三次握手呢？两次不行吗？")])]),v._v(" "),s("ul",[s("li",[v._v("为了确认双方的接收能力和发送能力都正常")]),v._v(" "),s("li",[v._v("如果是用两次握手，则会出现下面这种情况：")])]),v._v(" "),s("blockquote",[s("p",[v._v("如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。")])]),v._v(" "),s("p",[s("strong",[v._v("简单来说就是以下三步：")])]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("第一次握手：")]),v._v(" 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。")]),v._v(" "),s("li",[s("strong",[v._v("第二次握手：")]),v._v(" 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。")]),v._v(" "),s("li",[s("strong",[v._v("第三次握手：")]),v._v(" 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。")])]),v._v(" "),s("p",[v._v("TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。**")]),v._v(" "),s("h4",{attrs:{id:"四次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[v._v("#")]),v._v(" 四次挥手")]),v._v(" "),s("p",[s("img",{attrs:{src:t(1617),alt:"img"}}),v._v(" 刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：")]),v._v(" "),s("ul",[s("li",[v._v("第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。")])]),v._v(" "),s("blockquote",[s("p",[v._v("即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。")])]),v._v(" "),s("ul",[s("li",[v._v("第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。")])]),v._v(" "),s("blockquote",[s("p",[v._v("即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。")])]),v._v(" "),s("ul",[s("li",[v._v("第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。")])]),v._v(" "),s("blockquote",[s("p",[v._v("即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。")])]),v._v(" "),s("ul",[s("li",[v._v("第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。")])]),v._v(" "),s("blockquote",[s("p",[v._v("即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。")])]),v._v(" "),s("p",[s("strong",[v._v("那为什么需要四次挥手呢？")])]),v._v(" "),s("blockquote",[s("p",[v._v("因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。")])]),v._v(" "),s("p",[s("strong",[v._v("简单来说就是以下四步：")])]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("第一次挥手：")]),v._v(" 若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。")]),v._v(" "),s("li",[s("strong",[v._v("第二次挥手")]),v._v("：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。")]),v._v(" "),s("li",[s("strong",[v._v("第三次挥手")]),v._v("：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。")]),v._v(" "),s("li",[s("strong",[v._v("第四次挥手：")]),v._v(" 客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。")])]),v._v(" "),s("p",[v._v("TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。")]),v._v(" "),s("p",[v._v("最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。")]),v._v(" "),s("h3",{attrs:{id:"tcp三次握手-一句话概括"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手-一句话概括"}},[v._v("#")]),v._v(" tcp三次握手，一句话概括")]),v._v(" "),s("p",[s("strong",[v._v("客户端和服务端都需要直到各自可收发，因此需要三次握手。")])]),v._v(" "),s("p",[v._v("简化三次握手：")]),v._v(" "),s("p",[s("img",{attrs:{src:t(1618),alt:"2018-07-10 3 42 11"}})]),v._v(" "),s("p",[v._v("从图片可以得到三次握手可以简化为：C发起请求连接S确认，也发起连接C确认我们再看看每次握手的作用：第一次握手：S只可以确认 自己可以接受C发送的报文段第二次握手：C可以确认 S收到了自己发送的报文段，并且可以确认 自己可以接受S发送的报文段第三次握手：S可以确认 C收到了自己发送的报文段")]),v._v(" "),s("h3",{attrs:{id:"tcp和udp的区别-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别-2"}},[v._v("#")]),v._v(" TCP和UDP的区别")]),v._v(" "),s("p",[v._v("（1）TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。")]),v._v(" "),s("p",[v._v("（2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。")]),v._v(" "),s("p",[v._v("（3）TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。")]),v._v(" "),s("p",[v._v("（4）TCP只能是1对1的，UDP支持1对1,1对多。")]),v._v(" "),s("p",[v._v("（5）TCP的首部较大为20字节，而UDP只有8字节。")]),v._v(" "),s("p",[v._v("（6）TCP是面向连接的可靠性传输，而UDP是不可靠的。")]),v._v(" "),s("h2",{attrs:{id:"dns协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns协议"}},[v._v("#")]),v._v(" DNS协议")]),v._v(" "),s("h3",{attrs:{id:"dns-协议的概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns-协议的概念"}},[v._v("#")]),v._v(" DNS 协议的概念")]),v._v(" "),s("p",[s("strong",[v._v("概念")]),v._v("： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。")]),v._v(" "),s("p",[s("strong",[v._v("作用")]),v._v("： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的IP 地址。")]),v._v(" "),s("h3",{attrs:{id:"dns同时使用tcp和udp协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns同时使用tcp和udp协议"}},[v._v("#")]),v._v(" DNS同时使用TCP和UDP协议")]),v._v(" "),s("p",[s("strong",[v._v("DNS占用53号端口，同时使用TCP和UDP协议。")]),v._v(" （1）在区域传输的时候使用TCP协议")]),v._v(" "),s("ul",[s("li",[v._v("辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。")]),v._v(" "),s("li",[v._v("TCP是一种可靠连接，保证了数据的准确性。")])]),v._v(" "),s("p",[v._v("（2）在域名解析的时候使用UDP协议")]),v._v(" "),s("ul",[s("li",[v._v("客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。")])]),v._v(" "),s("h3",{attrs:{id:"dns完整的查询过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns完整的查询过程"}},[v._v("#")]),v._v(" DNS完整的查询过程")]),v._v(" "),s("p",[v._v("DNS服务器解析域名的过程：")]),v._v(" "),s("ul",[s("li",[v._v("首先会在"),s("strong",[v._v("浏览器的缓存")]),v._v("中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步")]),v._v(" "),s("li",[v._v("将请求发送给"),s("strong",[v._v("本地DNS服务器")]),v._v("，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步")]),v._v(" "),s("li",[v._v("本地DNS服务器向"),s("strong",[v._v("根域名服务器")]),v._v("发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址")]),v._v(" "),s("li",[v._v("本地DNS服务器向"),s("strong",[v._v("顶级域名服务器")]),v._v("发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址")]),v._v(" "),s("li",[v._v("本地DNS服务器向"),s("strong",[v._v("权威域名服务器")]),v._v("发送请求，域名服务器返回对应的结果")]),v._v(" "),s("li",[v._v("本地DNS服务器将返回结果保存在缓存中，便于下次使用")]),v._v(" "),s("li",[v._v("本地DNS服务器将返回结果返回给浏览器")])]),v._v(" "),s("p",[v._v("比如我们如果想要查询 "),s("a",{attrs:{href:"http://www.baidu.com/",target:"_blank",rel:"noopener noreferrer"}},[v._v("www.baidu.com"),s("OutboundLink")],1),v._v(" 的 IP 地址，我们首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。")]),v._v(" "),s("h3",{attrs:{id:"迭代查询与递归查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#迭代查询与递归查询"}},[v._v("#")]),v._v(" 迭代查询与递归查询")]),v._v(" "),s("p",[v._v("实际上，DNS解析是一个包含迭代查询和递归查询的过程。")]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("递归查询")]),v._v("指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。")]),v._v(" "),s("li",[s("strong",[v._v("迭代查询")]),v._v("指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。")])]),v._v(" "),s("p",[v._v("一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。")]),v._v(" "),s("h3",{attrs:{id:"dns-记录和报文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns-记录和报文"}},[v._v("#")]),v._v(" DNS 记录和报文")]),v._v(" "),s("p",[v._v("DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为")]),v._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[v._v("（Name，Value，Type，TTL）\n")])]),v._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[v._v("1")]),s("br")])]),s("p",[v._v("其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。")]),v._v(" "),s("p",[v._v("常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同。")]),v._v(" "),s("ol",[s("li",[v._v("如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。")]),v._v(" "),s("li",[v._v("如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。")]),v._v(" "),s("li",[v._v("如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。")]),v._v(" "),s("li",[v._v("如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);