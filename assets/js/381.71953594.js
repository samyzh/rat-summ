(window.webpackJsonp=window.webpackJsonp||[]).push([[381],{1947:function(v,_,t){"use strict";t.r(_);var e=t(14),l=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),t("p",[v._v("组件化就是基于可重用的目的，将一个大的软件系统按照分离关注点的形式，拆分成多个独立的组件，已较少耦合。")]),v._v(" "),t("ul",[t("li",[v._v("大部分来说，"),t("strong",[v._v("组件主要分三层，业务组件，基础业务组件以及基础组件")]),v._v("，组件之间只能通过接口耦合，也就是依赖倒置原则，每个组件都提供对外的接口文档以描述该组件提供的功能。")]),v._v(" "),t("li",[v._v("其次，说一下组件化的好处：解耦，平台化，职责单一，复用性，编译集成。\n"),t("ul",[t("li",[v._v("解耦：每个组件都是一个单一的工程（项目），对外只提供接口。组件之间的依赖只能通过接口，通过工程或者项目的方式，可以很大程度避免代码之间的耦合。")]),v._v(" "),t("li",[v._v("职责单一：每个组件只提供单一的功能，专项专用嘛，每个组件都可以单独去维护扩展，只要接口不变。")]),v._v(" "),t("li",[v._v("复用性强：基于职责单一，那么新项目中就可以依赖需要的组件。")]),v._v(" "),t("li",[v._v("平台化：这个其实是最有价值的，如果你作为一个平台产品，其他业务或者兄弟部门的开发同学想集成到你的产品中，那么他在开发测试的时候就很方便的依赖必须的组件，方便调试。这样，在多部门，多team去联合调试的时候，会节省很多的时间，但是这个要求文档必须要够完善，以便于其他人能够很方便的去接入。类似于：支付宝，美团等等平台级的产品。")]),v._v(" "),t("li",[v._v("编译集成：单个组件化组合成一个产品，对于编译来说可以很快速的定位问题以及快速编译，打包。")]),v._v(" "),t("li",[v._v("可能还有很多好处，后续补充哈。")])])]),v._v(" "),t("li",[v._v("组件化同样也会有一些问题，比如组件的粒度大小，如何区分业务组件以及基础业务组件。 这个就要根据具体项目具体分析了。总而言之一句话，一切皆组件。")]),v._v(" "),t("li",[v._v("组件化能"),t("code",[v._v("提⾼开发效率")]),v._v("，"),t("code",[v._v("⽅便重复使⽤")]),v._v("，"),t("code",[v._v("简化调试步骤")]),v._v("，"),t("code",[v._v("提升项⽬可维护性")]),v._v("，"),t("code",[v._v("便于多⼈协同开发")]),v._v("等。")])])])}),[],!1,null,null,null);_.default=l.exports}}]);