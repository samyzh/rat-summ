(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{1619:function(t,v,_){t.exports=_.p+"assets/img/41c0af03cade4115b4e082653344c50atplv-k3u1fbpfcp-zoom-1.16870e65.png"},1620:function(t,v,_){t.exports=_.p+"assets/img/be1ce45bb45d412499101b8b64161339tplv-k3u1fbpfcp-zoom-1.6671f897.png"},1621:function(t,v,_){t.exports=_.p+"assets/img/677456f993b54b63b73acca164698347tplv-k3u1fbpfcp-zoom-1.b510d435.png"},1622:function(t,v,_){t.exports=_.p+"assets/img/ac5f9b4b6def4e8e95b037d795b31f83tplv-k3u1fbpfcp-zoom-1.27688e1f.png"},1623:function(t,v,_){t.exports=_.p+"assets/img/bc8cd5be1c31465cab711813d01261f7tplv-k3u1fbpfcp-zoom-1.f0605c6c.png"},1624:function(t,v,_){t.exports=_.p+"assets/img/c209e3e3b88c44d5b60527e1ce88e435tplv-k3u1fbpfcp-zoom-1.0e1243e4.png"},1625:function(t,v,_){t.exports=_.p+"assets/img/d966b611db904d34a1deeb6f49e2a6a8tplv-k3u1fbpfcp-zoom-1.5edf773a.png"},1626:function(t,v,_){t.exports=_.p+"assets/img/27cf0762350f4aad91974c7a371001f5tplv-k3u1fbpfcp-zoom-1.c2f388e2.png"},2272:function(t,v,_){"use strict";_.r(v);var s=_(14),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"http协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http协议"}},[t._v("#")]),t._v(" HTTP协议")]),t._v(" "),s("h3",{attrs:{id:"get和post的请求的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get和post的请求的区别"}},[t._v("#")]),t._v(" GET和POST的请求的区别")]),t._v(" "),s("p",[t._v("Post 和 Get 是 HTTP 请求的两种方法。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("应用场景")]),t._v("：GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景。比如注册用户这一类的操作。")]),t._v(" "),s("li",[s("strong",[t._v("是否缓存")]),t._v("：因为不同的应用场景，所以浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。")]),t._v(" "),s("li",[s("strong",[t._v("请求长度")]),t._v("：浏览器由于对 url 有一个长度上的限制，所以会影响 get 请求发送数据时的长度。"),s("strong",[t._v("这个限制是浏览器规定的，并不是 RFC 规定的。")])]),t._v(" "),s("li",[s("strong",[t._v("安全性")]),t._v("：Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说，一个方面是不太安全，因为请求的 url 会被保留在历史记录中。")]),t._v(" "),s("li",[s("strong",[t._v("发送的报文格式")]),t._v("：Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。")]),t._v(" "),s("li",[s("strong",[t._v("参数类型")]),t._v("：post 的参数传递支持更多的数据类型。")])]),t._v(" "),s("h4",{attrs:{id:"get请求传参长度的误区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get请求传参长度的误区"}},[t._v("#")]),t._v(" get请求传参长度的误区")]),t._v(" "),s("p",[s("em",[s("strong",[t._v("误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。")])])]),t._v(" "),s("p",[t._v("实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:")]),t._v(" "),s("ul",[s("li",[t._v("HTTP 协议 未规定 GET 和POST的长度限制")]),t._v(" "),s("li",[t._v("GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度")]),t._v(" "),s("li",[t._v("不同的浏览器和WEB服务器，限制的最大长度不一样")]),t._v(" "),s("li",[t._v("要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte")])]),t._v(" "),s("h4",{attrs:{id:"补充get和post请求在缓存方面的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#补充get和post请求在缓存方面的区别"}},[t._v("#")]),t._v(" 补充get和post请求在缓存方面的区别")]),t._v(" "),s("p",[t._v("post/get的请求区别，具体不再赘述。")]),t._v(" "),s("p",[t._v("补充补充一个get和post在缓存方面的区别：")]),t._v(" "),s("ul",[s("li",[t._v("get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。")]),t._v(" "),s("li",[t._v("post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。")])]),t._v(" "),s("h3",{attrs:{id:"post和put请求的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#post和put请求的区别"}},[t._v("#")]),t._v(" POST和PUT请求的区别")]),t._v(" "),s("ul",[s("li",[t._v("PUT请求是向服务器端发送数据的，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时"),s("strong",[t._v("更新数据")]),t._v("）")]),t._v(" "),s("li",[t._v("POST请求是向服务器端发送数据的，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是"),s("strong",[t._v("创建数据")]),t._v("）")])]),t._v(" "),s("h3",{attrs:{id:"常见的http请求头和响应头"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的http请求头和响应头"}},[t._v("#")]),t._v(" 常见的HTTP请求头和响应头")]),t._v(" "),s("p",[s("strong",[t._v("HTTP Request Header 常见的请求头：")])]),t._v(" "),s("ul",[s("li",[t._v("Accept:浏览器能够处理的内容类型")]),t._v(" "),s("li",[t._v("Accept-Charset:浏览器能够显示的字符集")]),t._v(" "),s("li",[t._v("Accept-Encoding：浏览器能够处理的压缩编码")]),t._v(" "),s("li",[t._v("Accept-Language：浏览器当前设置的语言")]),t._v(" "),s("li",[t._v("Connection：浏览器与服务器之间连接的类型")]),t._v(" "),s("li",[t._v("Cookie：当前页面设置的任何Cookie")]),t._v(" "),s("li",[t._v("Host：发出请求的页面所在的域")]),t._v(" "),s("li",[t._v("Referer：发出请求的页面的URL")]),t._v(" "),s("li",[t._v("User-Agent：浏览器的用户代理字符串")])]),t._v(" "),s("p",[s("strong",[t._v("HTTP Responses Header 常见的响应头：")])]),t._v(" "),s("ul",[s("li",[t._v("Date：表示消息发送的时间，时间的描述格式由rfc822定义")]),t._v(" "),s("li",[t._v("server:服务器名字")]),t._v(" "),s("li",[t._v("Connection：浏览器与服务器之间连接的类型")]),t._v(" "),s("li",[t._v("Cache-Control：控制HTTP缓存")]),t._v(" "),s("li",[t._v("content-type:表示后面的文档属于什么MIME类型")])]),t._v(" "),s("p",[t._v("常见的 Content-Type 属性值有以下四种：")]),t._v(" "),s("p",[t._v("（1）application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。")]),t._v(" "),s("p",[t._v("（2）multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。")]),t._v(" "),s("p",[t._v("（3）application/json：告诉服务器消息主体是序列化后的 JSON 字符串。")]),t._v(" "),s("p",[t._v("（4）text/xml：该种方式主要用来提交 XML 格式的数据。")]),t._v(" "),s("h3",{attrs:{id:"http状态码304是多好还是少好"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http状态码304是多好还是少好"}},[t._v("#")]),t._v(" HTTP状态码304是多好还是少好")]),t._v(" "),s("p",[t._v("服务器为了提高网站访问速度，对之前访问的部分页面制定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。")]),t._v(" "),s("p",[t._v("状态码304不应该认为是一种错误，而是对客户端"),s("strong",[t._v("有缓存情况下")]),t._v("服务端的一种响应。")]),t._v(" "),s("p",[t._v("搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。")]),t._v(" "),s("p",[s("strong",[t._v("产生较多304状态码的原因：")])]),t._v(" "),s("ul",[s("li",[t._v("页面更新周期长或不更新")]),t._v(" "),s("li",[t._v("纯静态页面或强制生成静态html")])]),t._v(" "),s("p",[s("strong",[t._v("304状态码出现过多会造成以下问题：")])]),t._v(" "),s("ul",[s("li",[t._v("网站快照停止")]),t._v(" "),s("li",[t._v("收录减少")]),t._v(" "),s("li",[t._v("权重下降")])]),t._v(" "),s("h3",{attrs:{id:"常见的http请求方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的http请求方法"}},[t._v("#")]),t._v(" 常见的HTTP请求方法")]),t._v(" "),s("ul",[s("li",[t._v("GET: 向服务器获取数据")]),t._v(" "),s("li",[t._v("POST：将实体提交到指定的资源，通常会造成服务器资源的修改。")]),t._v(" "),s("li",[t._v("PUT：上传文件，修改数据")]),t._v(" "),s("li",[t._v("DELETE：删除服务器上的对象")]),t._v(" "),s("li",[t._v("HEAD：获取报文首部，与GET相比，不返回报文主体部分")]),t._v(" "),s("li",[t._v("OPTIONS：询问支持的请求方法，用来跨域请求")]),t._v(" "),s("li",[t._v("TRACE：追踪 请求—响应 的传输路径")]),t._v(" "),s("li",[t._v("CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信")])]),t._v(" "),s("h3",{attrs:{id:"options请求方法及使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#options请求方法及使用场景"}},[t._v("#")]),t._v(" options请求方法及使用场景")]),t._v(" "),s("p",[t._v("OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。")]),t._v(" "),s("p",[t._v("OPTIONS方法是用于请求获得由"),s("code",[t._v("Request-URI")]),t._v("标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以"),s("strong",[t._v("在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能")]),t._v("。该请求方法的响应不能缓存。")]),t._v(" "),s("p",[t._v("OPTIONS请求方法的"),s("strong",[t._v("主要用途")]),t._v("有两个：")]),t._v(" "),s("ul",[s("li",[t._v("获取服务器支持的所有HTTP请求方法；")]),t._v(" "),s("li",[t._v("用来检查访问权限。例如：JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。")])]),t._v(" "),s("h3",{attrs:{id:"http请求的方式-head方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http请求的方式-head方式"}},[t._v("#")]),t._v(" HTTP请求的方式，HEAD方式")]),t._v(" "),s("ul",[s("li",[t._v("head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头")]),t._v(" "),s("li",[t._v("options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。")])]),t._v(" "),s("h3",{attrs:{id:"http-1-0和-http-1-1-之间有哪些区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0和-http-1-1-之间有哪些区别"}},[t._v("#")]),t._v(" HTTP 1.0和 HTTP 1.1 之间有哪些区别？")]),t._v(" "),s("p",[s("strong",[t._v("HTTP 1.0和 HTTP 1.1 有以下区别")]),t._v("：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("连接方面")]),t._v(" 的区别，http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。")]),t._v(" "),s("li",[s("strong",[t._v("资源请求方面")]),t._v(" 的区别，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。")]),t._v(" "),s("li",[s("strong",[t._v("缓存方面")]),t._v(" 的区别，在 http1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。")]),t._v(" "),s("li",[t._v("http1.1 中还"),s("strong",[t._v("新增了 host 字段")]),t._v("，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，就可以将请求发往同一台服务器上的不同网站。")]),t._v(" "),s("li",[t._v("http1.1 相对于 http1.0 还新增了很多"),s("strong",[t._v("请求方法")]),t._v("，如 PUT、HEAD、OPTIONS 等。")])]),t._v(" "),s("h3",{attrs:{id:"http-1-1和-http-2-0-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1和-http-2-0-的区别"}},[t._v("#")]),t._v(" HTTP 1.1和 HTTP 2.0 的区别")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("二进制协议")]),t._v('：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是 二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。')]),t._v(" "),s("li",[s("strong",[t._v("多路复用：")]),t._v(' HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回 应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"的问题。')]),t._v(" "),s("li",[s("strong",[t._v("数据流：")]),t._v(" HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的 请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每 个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID ，用来区分它属于哪个数据流。")]),t._v(" "),s("li",[s("strong",[t._v("头信息压缩：")]),t._v(" HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是 重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面， 客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引 号，这样就能提高速度了。")]),t._v(" "),s("li",[s("strong",[t._v("服务器推送：")]),t._v(" HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送，提前给客户端推送必要的资源 ，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。")])]),t._v(" "),s("h3",{attrs:{id:"http和https协议的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http和https协议的区别"}},[t._v("#")]),t._v(" HTTP和HTTPS协议的区别")]),t._v(" "),s("p",[t._v("HTTP和HTTPS协议的主要区别如下：")]),t._v(" "),s("ul",[s("li",[t._v("HTTPS协议需要CA证书，费用较高；HTTP协议不需要")]),t._v(" "),s("li",[t._v("HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议")]),t._v(" "),s("li",[t._v("使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS的协议端口是443")]),t._v(" "),s("li",[t._v("HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全")])]),t._v(" "),s("h3",{attrs:{id:"get方法url长度限制的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get方法url长度限制的原因"}},[t._v("#")]),t._v(" GET方法URL长度限制的原因")]),t._v(" "),s("p",[t._v("实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。 IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),t._v("的长度值 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("URL")]),t._v("（"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2083")]),t._v("）"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" （你的Domain"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("Path）"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("（"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("是"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("get")]),t._v("请求中"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("两个字符的长度）\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("下面看一下主流浏览器对get方法中url的长度限制范围：")]),t._v(" "),s("ul",[s("li",[t._v("Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。")]),t._v(" "),s("li",[t._v("Firefox (Browser)：对于Firefox浏览器URL的长度限制为65,536个字符。")]),t._v(" "),s("li",[t._v("Safari (Browser)：URL最大长度限制为 80,000个字符。")]),t._v(" "),s("li",[t._v("Opera (Browser)：URL最大长度限制为190,000个字符。")]),t._v(" "),s("li",[t._v("Google (chrome)：URL最大长度限制为8182个字符。")])]),t._v(" "),s("p",[t._v("再来看一下主流的服务器对get方法中url的长度限制范围：")]),t._v(" "),s("ul",[s("li",[t._v("Apache (Server)：能接受最大url长度为8,192个字符。")]),t._v(" "),s("li",[t._v("Microsoft Internet Information Server(IIS)：能接受最大url的长度为16,384个字符。")])]),t._v(" "),s("p",[t._v("根据上面的数据，我们可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。")]),t._v(" "),s("h3",{attrs:{id:"当你在浏览器中输入-google-com-并且按下回车之后发生了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当你在浏览器中输入-google-com-并且按下回车之后发生了什么"}},[t._v("#")]),t._v(" 当你在浏览器中输入 Google.com 并且按下回车之后发生了什么？")]),t._v(" "),s("p",[t._v("（1）首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。")]),t._v(" "),s("p",[t._v("（2）浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。")]),t._v(" "),s("p",[t._v("（3）下一步我们首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。")]),t._v(" "),s("p",[t._v("（4）当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址，如果我们不在一个子网里，那么我们的请求应该转发给我们的网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。")]),t._v(" "),s("p",[t._v("（5）下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。")]),t._v(" "),s("p",[t._v("（6）如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。")]),t._v(" "),s("p",[t._v("（7）当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。")]),t._v(" "),s("p",[t._v("（8）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。")]),t._v(" "),s("p",[t._v("（9）最后一步是 TCP 断开连接的四次挥手过程。")]),t._v(" "),s("h3",{attrs:{id:"对keep-alive的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对keep-alive的理解"}},[t._v("#")]),t._v(" 对keep-alive的理解")]),t._v(" "),s("p",[t._v("HTTP1.0 中默认是在一次每个请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是"),s("strong",[t._v("短连接")]),t._v("。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是"),s("strong",[t._v("长连接")]),t._v("。")]),t._v(" "),s("ul",[s("li",[t._v("HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送"),s("code",[t._v("connection:keep-alive")]),t._v("字段。若想断开keep-alive连接，需发送"),s("code",[t._v("Connection:close")]),t._v("字段")]),t._v(" "),s("li",[t._v("HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送Connection：close首部字段。")])]),t._v(" "),s("p",[t._v("Keep-Alive的"),s("strong",[t._v("建立过程")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("客户端向服务器在发送请求报文同时在首部添加发送Connection字段")]),t._v(" "),s("li",[t._v("服务器收到请求并处理connection字段")]),t._v(" "),s("li",[t._v("服务器回送Connection:Keep-Alive字段给客户端")]),t._v(" "),s("li",[t._v("客户端接收到connection字段")]),t._v(" "),s("li",[t._v("Keep-Alive连接建立成功")])]),t._v(" "),s("p",[s("strong",[t._v("服务端自动断开过程（也就是没有keep-alive）")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("客户端向服务器只是发送内容报文（不包含Connection字段）")]),t._v(" "),s("li",[t._v("服务器收到请求并处理")]),t._v(" "),s("li",[t._v("服务器返回客户端请求的资源并关闭连接")]),t._v(" "),s("li",[t._v("客户端接收资源，发现没有Connection字段，断开连接")])]),t._v(" "),s("p",[s("strong",[t._v("客户端请求断开连接过程")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("客户端向服务器发送Connection:close字段")]),t._v(" "),s("li",[t._v("服务器收到请求并处理connection字段")]),t._v(" "),s("li",[t._v("服务器回送响应资源并断开连接")]),t._v(" "),s("li",[t._v("客户端接收资源并断开连接")])]),t._v(" "),s("p",[t._v("开启Keep-Alive的"),s("strong",[t._v("优缺点")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("优点：Keep-Alive模式更加高效，因为避免了连接建立和释放的开销。")]),t._v(" "),s("li",[t._v("缺点：长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。")])]),t._v(" "),s("h3",{attrs:{id:"页面有多张图片-http是怎样的加载表现-如何解决"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面有多张图片-http是怎样的加载表现-如何解决"}},[t._v("#")]),t._v(" 页面有多张图片，HTTP是怎样的加载表现，如何解决？")]),t._v(" "),s("ul",[s("li",[t._v("在"),s("code",[t._v("HTTP 1")]),t._v("下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用"),s("strong",[t._v("多域名部署")]),t._v("解决。 这样可以提高同时请求的数目，加快页面图片的获取速度。")]),t._v(" "),s("li",[t._v("在"),s("code",[t._v("HTTP 2")]),t._v("下，可以一瞬间加载出来所有的资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。")])]),t._v(" "),s("h3",{attrs:{id:"http2的头部压缩算法是怎样的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http2的头部压缩算法是怎样的"}},[t._v("#")]),t._v(" HTTP2的头部压缩算法是怎样的？")]),t._v(" "),s("p",[s("strong",[t._v("HTTP2的头部压缩是HPACK算法")]),t._v("。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。")]),t._v(" "),s("p",[t._v("具体来说:")]),t._v(" "),s("ul",[s("li",[t._v("在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；")]),t._v(" "),s("li",[t._v("首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；")]),t._v(" "),s("li",[t._v("每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。")])]),t._v(" "),s("p",[t._v("例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。 "),s("img",{attrs:{src:_(1619),alt:"img"}})]),t._v(" "),s("h3",{attrs:{id:"http请求报文和响应报文的组成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http请求报文和响应报文的组成"}},[t._v("#")]),t._v(" HTTP请求报文和响应报文的组成")]),t._v(" "),s("p",[t._v("HTTP协议报文的结构： "),s("img",{attrs:{src:_(1620),alt:"image.png"}})]),t._v(" "),s("h4",{attrs:{id:"http-请求报文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-请求报文"}},[t._v("#")]),t._v(" HTTP 请求报文")]),t._v(" "),s("p",[t._v("HTTP 报文有两种，一种是请求报文，一种是响应报文。")]),t._v(" "),s("p",[t._v("HTTP 请求报文的格式如下：")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[t._v("GET / HTTP/1.1\n"),s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("User-Agent:")]),t._v(" Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)\n"),s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Accept:")]),t._v(" */*\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[t._v("HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。")]),t._v(" "),s("p",[t._v("请求行包含三个字段：")]),t._v(" "),s("ul",[s("li",[t._v("方法字段")]),t._v(" "),s("li",[t._v("URL 字段")]),t._v(" "),s("li",[t._v("HTTP 版本字段。")])]),t._v(" "),s("p",[t._v("请求"),s("strong",[t._v("方法字段")]),t._v("可以取以下的值：")]),t._v(" "),s("ul",[s("li",[t._v("GET: 向服务器获取数据")]),t._v(" "),s("li",[t._v("POST：将实体提交到指定的资源，通常会造成服务器资源的修改。")]),t._v(" "),s("li",[t._v("PUT：上传文件，修改数据")]),t._v(" "),s("li",[t._v("DELETE：删除服务器上的对象")]),t._v(" "),s("li",[t._v("HEAD：获取报文首部，与GET相比，不返回报文主体部分")]),t._v(" "),s("li",[t._v("OPTIONS：询问支持的请求方法，用来跨域请求")]),t._v(" "),s("li",[t._v("TRACE：追踪 请求—响应 的传输路径")]),t._v(" "),s("li",[t._v("CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信")])]),t._v(" "),s("p",[t._v("虽然请求的方法很多，但更多表达的是一种语义上的区别，并不是说 POST 能做的事情，GET 就不能做了，主要看我们如何选择。")]),t._v(" "),s("h4",{attrs:{id:"http-响应报文"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-响应报文"}},[t._v("#")]),t._v(" HTTP 响应报文")]),t._v(" "),s("p",[t._v("HTTP 报文有两种，一种是请求报文，一种是响应报文。")]),t._v(" "),s("p",[t._v("HTTP 响应报文的格式如下：")]),t._v(" "),s("div",{staticClass:"language-http line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[t._v("HTTP/1.0 "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("200 OK")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Content-Type:")]),t._v(" text/plain\n"),s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Content-Length:")]),t._v(" 137582\n"),s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Expires:")]),t._v(" Thu, 05 Dec 1997 16:00:00 GMT\n"),s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Last-Modified:")]),t._v(" Wed, 5 August 1996 15:55:28 GMT\n"),s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Server:")]),t._v(" Apache 0.84\n<html>\n  <body>Hello World</body>\n</html>\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[t._v("HTTP 响应报文的第一行叫做"),s("strong",[t._v("状态行")]),t._v("，后面的行是"),s("strong",[t._v("首部行")]),t._v("，最后是"),s("strong",[t._v("实体主体")]),t._v("。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("状态行")]),t._v("包含了三个字段：协议版本字段、状态码和相应的状态信息。")]),t._v(" "),s("li",[s("strong",[t._v("实体部分")]),t._v("是报文的主要部分，它包含了所请求的对象。")]),t._v(" "),s("li",[s("strong",[t._v("首部行")]),t._v("首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。")])]),t._v(" "),s("p",[t._v("（1）常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。")]),t._v(" "),s("p",[t._v("（2）常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。")]),t._v(" "),s("p",[t._v("（3）常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。")]),t._v(" "),s("p",[t._v("（4）常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。")]),t._v(" "),s("h3",{attrs:{id:"http协议的优点和缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http协议的优点和缺点"}},[t._v("#")]),t._v(" HTTP协议的优点和缺点")]),t._v(" "),s("p",[t._v("HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。")]),t._v(" "),s("p",[t._v("HTTP协议具有以下"),s("strong",[t._v("优点")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("支持客户端/服务器模式")]),t._v(" "),s("li",[s("strong",[t._v("简单快速")]),t._v("：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。")]),t._v(" "),s("li",[s("strong",[t._v("无连接")]),t._v("：无连接的含义是限制每次链接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开链接，采用这种方式可以节省传输时间。")]),t._v(" "),s("li",[s("strong",[t._v("无状态")]),t._v("：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。")]),t._v(" "),s("li",[s("strong",[t._v("灵活")]),t._v("：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。")])]),t._v(" "),s("p",[t._v("HTTP协议具有以下"),s("strong",[t._v("缺点")]),t._v("：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("无状态：")]),t._v(" HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。")]),t._v(" "),s("li",[s("strong",[t._v("明文传输：")]),t._v(" 协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。")]),t._v(" "),s("li",[s("strong",[t._v("不安全")])])]),t._v(" "),s("p",[t._v("（1）通信使用明文（不加密），内容可能会被窃听 （2）不验证通信方的身份，因此有可能遭遇伪装 （3）无法证明报文的完整性，所以有可能已遭篡改")]),t._v(" "),s("h3",{attrs:{id:"说一下http-3-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说一下http-3-0"}},[t._v("#")]),t._v(" 说一下HTTP 3.0")]),t._v(" "),s("p",[t._v("HTTP/3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。 "),s("img",{attrs:{src:_(1621),alt:"img"}})]),t._v(" "),s("ol",[s("li",[s("p",[t._v("流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。")])]),t._v(" "),s("li",[s("p",[t._v("集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。")])]),t._v(" "),s("li",[s("p",[t._v("多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。"),s("img",{attrs:{src:_(1622),alt:"img"}})])]),t._v(" "),s("li",[s("p",[t._v("快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。")])])]),t._v(" "),s("h3",{attrs:{id:"http协议的性能怎么样"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http协议的性能怎么样"}},[t._v("#")]),t._v(" HTTP协议的性能怎么样")]),t._v(" "),s("p",[t._v("HTTP 协议是基于 TCP/IP，并且使用了"),s("strong",[t._v("请求-应答")]),t._v("的通信模式，所以性能的关键就在这两点里。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("长连接")])])]),t._v(" "),s("p",[t._v("HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。 （1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。 （2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。")]),t._v(" "),s("p",[t._v("对于不同版本的采用不同的连接方式：")]),t._v(" "),s("ul",[s("li",[t._v("在HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。")]),t._v(" "),s("li",[t._v("在HTTP/1.1 提出了"),s("strong",[t._v("长连接")]),t._v("的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。")])]),t._v(" "),s("p",[s("img",{attrs:{src:_(1623),alt:"img"}})]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("管道网络传输")])])]),t._v(" "),s("p",[t._v("HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。")]),t._v(" "),s("p",[t._v("管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("队头堵塞")])])]),t._v(" "),s("p",[t._v("HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。")]),t._v(" "),s("p",[s("strong",[t._v("队头阻塞的解决方案：")]),t._v(" （1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。")]),t._v(" "),s("h3",{attrs:{id:"http和https"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http和https"}},[t._v("#")]),t._v(" http和https")]),t._v(" "),s("p",[s("strong",[t._v("https的SSL加密是在传输层实现的。")])]),t._v(" "),s("h4",{attrs:{id:"_1-http和https的基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-http和https的基本概念"}},[t._v("#")]),t._v(" (1)http和https的基本概念")]),t._v(" "),s("p",[t._v("http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。")]),t._v(" "),s("p",[t._v("https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。")]),t._v(" "),s("p",[t._v("https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。")]),t._v(" "),s("h4",{attrs:{id:"_2-http和https的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-http和https的区别"}},[t._v("#")]),t._v(" (2)http和https的区别？")]),t._v(" "),s("p",[t._v("http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。 主要的区别如下：")]),t._v(" "),s("ul",[s("li",[t._v("Https协议需要ca证书，费用较高。")]),t._v(" "),s("li",[t._v("http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。")]),t._v(" "),s("li",[t._v("使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443")]),t._v(" "),s("li",[t._v("http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。")])]),t._v(" "),s("h4",{attrs:{id:"_3-https协议的工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-https协议的工作原理"}},[t._v("#")]),t._v(" (3)https协议的工作原理")]),t._v(" "),s("p",[t._v("客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。")]),t._v(" "),s("ul",[s("li",[t._v("客户使用https url访问服务器，则要求web 服务器建立ssl链接。")]),t._v(" "),s("li",[t._v("web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。")]),t._v(" "),s("li",[t._v("客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。")]),t._v(" "),s("li",[t._v("客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。")]),t._v(" "),s("li",[t._v("web服务器通过自己的私钥解密出会话密钥。")]),t._v(" "),s("li",[t._v("web服务器通过会话密钥加密与客户端之间的通信。")])]),t._v(" "),s("h4",{attrs:{id:"_4-https协议的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-https协议的优点"}},[t._v("#")]),t._v(" (4)https协议的优点")]),t._v(" "),s("ul",[s("li",[t._v("使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；")]),t._v(" "),s("li",[t._v("HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。")]),t._v(" "),s("li",[t._v("HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。")]),t._v(" "),s("li",[t._v("谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。")])]),t._v(" "),s("h4",{attrs:{id:"_5-https协议的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-https协议的缺点"}},[t._v("#")]),t._v(" (5)https协议的缺点")]),t._v(" "),s("ul",[s("li",[t._v("https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。")]),t._v(" "),s("li",[t._v("https缓存不如http高效，会增加数据开销。")]),t._v(" "),s("li",[t._v("SSL证书也需要钱，功能越强大的证书费用越高。")]),t._v(" "),s("li",[t._v("SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。")])]),t._v(" "),s("h3",{attrs:{id:"一个图片url访问后直接下载怎样实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一个图片url访问后直接下载怎样实现"}},[t._v("#")]),t._v(" 一个图片url访问后直接下载怎样实现？")]),t._v(" "),s("p",[t._v("请求的返回头里面，用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为的参数。")]),t._v(" "),s("p",[t._v("下载的情况下：")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("  1. x-oss-object-type:\n         Normal\n  2. x-oss-request-id:\n         598D5ED34F29D01FE2925F41\n  3. x-oss-storage-class:\n         Standard\n\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("h3",{attrs:{id:"http2-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http2-0"}},[t._v("#")]),t._v(" http2.0")]),t._v(" "),s("p",[t._v("首先补充一下，http和https的区别，相比于http,https是基于ssl加密的http协议 简要概括：http2.0是基于1999年发布的http1.0之后的首次更新。")]),t._v(" "),s("ul",[s("li",[t._v("提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0）")]),t._v(" "),s("li",[t._v("允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。")]),t._v(" "),s("li",[t._v("二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码")]),t._v(" "),s("li",[t._v("首部压缩")]),t._v(" "),s("li",[t._v("服务器端推送")])]),t._v(" "),s("h3",{attrs:{id:"fetch发送2次请求的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fetch发送2次请求的原因"}},[t._v("#")]),t._v(" fetch发送2次请求的原因")]),t._v(" "),s("p",[s("strong",[t._v("fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？")])]),t._v(" "),s("p",[t._v("原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。")]),t._v(" "),s("h2",{attrs:{id:"缓存相关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存相关"}},[t._v("#")]),t._v(" 缓存相关")]),t._v(" "),s("h3",{attrs:{id:"缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),s("p",[t._v("浏览器缓存分为强缓存和协商缓存，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。 控制强缓存的字段有：Expires和Cache-Control，Expires 和 Cache-Control。 控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。")]),t._v(" "),s("h2",{attrs:{id:"https协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https协议"}},[t._v("#")]),t._v(" HTTPS协议")]),t._v(" "),s("h3",{attrs:{id:"什么是https协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是https协议"}},[t._v("#")]),t._v(" 什么是HTTPS协议？")]),t._v(" "),s("p",[t._v("超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。 "),s("img",{attrs:{src:_(1624),alt:"img"}}),t._v(" HTTP协议采用"),s("strong",[t._v("明文传输")]),t._v("信息，存在"),s("strong",[t._v("信息窃听")]),t._v("、"),s("strong",[t._v("信息篡改")]),t._v("和"),s("strong",[t._v("信息劫持")]),t._v("的风险，而协议TLS/SSL具有"),s("strong",[t._v("身份验证")]),t._v("、"),s("strong",[t._v("信息加密")]),t._v("和"),s("strong",[t._v("完整性校验")]),t._v("的功能，可以避免此类问题发生。 安全层的主要职责就是"),s("strong",[t._v("对发起的HTTP请求的数据进行加密操作")]),t._v(" 和 "),s("strong",[t._v("对接收到的HTTP的内容进行解密操作")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"tls-ssl的工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tls-ssl的工作原理"}},[t._v("#")]),t._v(" TLS/SSL的工作原理")]),t._v(" "),s("p",[s("strong",[t._v("TLS/SSL")]),t._v("全称安全传输层协议（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。 TLS/SSL的功能实现主要依赖三类基本算法："),s("strong",[t._v("散列函数hash")]),t._v("、"),s("strong",[t._v("对称加密")]),t._v("、"),s("strong",[t._v("非对称加密")]),t._v("。这三类算法的作用如下：")]),t._v(" "),s("ul",[s("li",[t._v("基于散列函数验证信息的完整性")]),t._v(" "),s("li",[t._v("对称加密算法采用协商的秘钥对数据加密")]),t._v(" "),s("li",[t._v("非对称加密实现身份认证和秘钥协商 "),s("img",{attrs:{src:_(1625),alt:"img"}})])]),t._v(" "),s("h4",{attrs:{id:"散列函数hash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#散列函数hash"}},[t._v("#")]),t._v(" 散列函数hash")]),t._v(" "),s("p",[t._v("常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。 "),s("strong",[t._v("特点：")]),t._v(" 在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。")]),t._v(" "),s("h4",{attrs:{id:"对称加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对称加密"}},[t._v("#")]),t._v(" 对称加密")]),t._v(" "),s("p",[t._v("对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就 是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。")]),t._v(" "),s("p",[t._v("常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。")]),t._v(" "),s("p",[s("strong",[t._v("特点：")]),t._v(" 对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。")]),t._v(" "),s("h4",{attrs:{id:"非对称加密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[t._v("#")]),t._v(" 非对称加密")]),t._v(" "),s("p",[t._v("非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只 有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加 密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。")]),t._v(" "),s("p",[t._v("常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。")]),t._v(" "),s("p",[s("strong",[t._v("特点：")]),t._v(" 非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。")]),t._v(" "),s("p",[t._v("综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。")]),t._v(" "),s("h3",{attrs:{id:"数字证书"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数字证书"}},[t._v("#")]),t._v(" 数字证书")]),t._v(" "),s("p",[t._v("现在的方法也不一定是安全的，因为我们没有办法确定我们得到的公钥就一定是安全的公钥。可能存在一个中间人，截取 了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥 解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。")]),t._v(" "),s("p",[t._v("为了解决这样的问题，我们可以使用数字证书的方式，首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成 一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合 在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证 处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和我们生成的摘要进行对比，就能发现我们得到的信息是否被更改 了。这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有 这样我们才能保证数据的安全。 "),s("img",{attrs:{src:_(1626),alt:"img"}})]),t._v(" "),s("h3",{attrs:{id:"https通信-握手-过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https通信-握手-过程"}},[t._v("#")]),t._v(" HTTPS通信（握手）过程")]),t._v(" "),s("p",[t._v("HTTPS的通信过程如下：")]),t._v(" "),s("ul",[s("li",[t._v("第一步，客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。")]),t._v(" "),s("li",[t._v("第二步，服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。")]),t._v(" "),s("li",[t._v("第三步，客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。")]),t._v(" "),s("li",[t._v("第四步，服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。")]),t._v(" "),s("li",[t._v("第五步，客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥 来加密信息。")])]),t._v(" "),s("h3",{attrs:{id:"https的特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https的特点"}},[t._v("#")]),t._v(" HTTPS的特点")]),t._v(" "),s("p",[t._v("HTTPS的"),s("strong",[t._v("优点")]),t._v("如下：")]),t._v(" "),s("ul",[s("li",[t._v("使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器")]),t._v(" "),s("li",[t._v("使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性。")]),t._v(" "),s("li",[t._v("HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本")])]),t._v(" "),s("p",[t._v("HTTPS的"),s("strong",[t._v("缺点")]),t._v("如下：")]),t._v(" "),s("ul",[s("li",[t._v("HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂")]),t._v(" "),s("li",[t._v("HTTPS协议握手阶段比较费时，增加页面的加载时间")]),t._v(" "),s("li",[t._v("SSL证书是收费的，功能越强大的证书费用越高")]),t._v(" "),s("li",[t._v("HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本")]),t._v(" "),s("li",[t._v("SSL证书需要绑定IP，不能再同一个IP上绑定多个域名")])]),t._v(" "),s("h2",{attrs:{id:"http状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[t._v("#")]),t._v(" HTTP状态码")]),t._v(" "),s("p",[t._v("状态码的类别：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("strong",[t._v("类别")])]),t._v(" "),s("th",[s("strong",[t._v("原因")])]),t._v(" "),s("th",[s("strong",[t._v("描述")])])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("1xx")]),t._v(" "),s("td",[t._v("Informational(信息性状态码)")]),t._v(" "),s("td",[t._v("接受的请求正在处理")])]),t._v(" "),s("tr",[s("td",[t._v("2xx")]),t._v(" "),s("td",[t._v("Success(成功状态码)")]),t._v(" "),s("td",[t._v("请求正常处理完毕")])]),t._v(" "),s("tr",[s("td",[t._v("3xx")]),t._v(" "),s("td",[t._v("Redirection(重定向状态码)")]),t._v(" "),s("td",[t._v("需要进行附加操作一完成请求")])]),t._v(" "),s("tr",[s("td",[t._v("4xx")]),t._v(" "),s("td",[t._v("Client Error (客户端错误状态码)")]),t._v(" "),s("td",[t._v("服务器无法处理请求")])]),t._v(" "),s("tr",[s("td",[t._v("5xx")]),t._v(" "),s("td",[t._v("Server Error(服务器错误状态码)")]),t._v(" "),s("td",[t._v("服务器处理请求出错")])])])]),t._v(" "),s("h3",{attrs:{id:"_2xx-success-成功状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2xx-success-成功状态码"}},[t._v("#")]),t._v(" 2XX (Success 成功状态码)")]),t._v(" "),s("p",[t._v("状态码2XX表示请求被正常处理了。")]),t._v(" "),s("h4",{attrs:{id:"_200-ok"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_200-ok"}},[t._v("#")]),t._v(" 200 OK")]),t._v(" "),s("p",[t._v("200 OK表示客户端发来的请求被服务器端正常处理了。")]),t._v(" "),s("h4",{attrs:{id:"_204-no-content"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_204-no-content"}},[t._v("#")]),t._v(" 204 No Content")]),t._v(" "),s("p",[t._v("该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。 一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。")]),t._v(" "),s("h4",{attrs:{id:"_206-partial-content"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_206-partial-content"}},[t._v("#")]),t._v(" 206 Partial Content")]),t._v(" "),s("p",[t._v("该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。")]),t._v(" "),s("h3",{attrs:{id:"_3xx-redirection-重定向状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3xx-redirection-重定向状态码"}},[t._v("#")]),t._v(" 3XX (Redirection 重定向状态码)")]),t._v(" "),s("p",[t._v("3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。")]),t._v(" "),s("h4",{attrs:{id:"_301-moved-permanently"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_301-moved-permanently"}},[t._v("#")]),t._v(" 301 Moved Permanently")]),t._v(" "),s("p",[s("strong",[t._v("永久重定向。")]),t._v(" 该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。 若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。 同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。")]),t._v(" "),s("p",[s("strong",[t._v("使用场景：")])]),t._v(" "),s("ul",[s("li",[t._v("当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。")]),t._v(" "),s("li",[t._v("在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。")])]),t._v(" "),s("h4",{attrs:{id:"_302-found"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_302-found"}},[t._v("#")]),t._v(" 302 Found")]),t._v(" "),s("p",[s("strong",[t._v("临时重定向。")]),t._v(" 该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。 和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。 若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。 同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。")]),t._v(" "),s("p",[s("strong",[t._v("使用场景：")])]),t._v(" "),s("ul",[s("li",[t._v("当我们在做活动时，登录到首页自动重定向，进入活动页面。")]),t._v(" "),s("li",[t._v("未登陆的用户访问用户中心重定向到登录页面。")]),t._v(" "),s("li",[t._v("访问404页面重新定向到首页。")])]),t._v(" "),s("h4",{attrs:{id:"_303-see-other"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_303-see-other"}},[t._v("#")]),t._v(" 303 See Other")]),t._v(" "),s("p",[t._v("该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。 303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。 注意：")]),t._v(" "),s("blockquote",[s("p",[t._v("当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。 301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。")])]),t._v(" "),s("h4",{attrs:{id:"_304-not-modified"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_304-not-modified"}},[t._v("#")]),t._v(" 304 Not Modified")]),t._v(" "),s("p",[s("strong",[t._v("浏览器缓存相关。")]),t._v(" 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。")]),t._v(" "),s("p",[t._v("带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（"),s("code",[t._v("if-match")]),t._v("、"),s("code",[t._v("if-none-match")]),t._v("、"),s("code",[t._v("if-modified-since")]),t._v("、"),s("code",[t._v("if-unmodified-since")]),t._v("、"),s("code",[t._v("if-range")]),t._v("）中任意首部。")]),t._v(" "),s("p",[t._v("状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。")]),t._v(" "),s("h4",{attrs:{id:"_307-temporary-redirect"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_307-temporary-redirect"}},[t._v("#")]),t._v(" 307 Temporary Redirect")]),t._v(" "),s("p",[s("strong",[t._v("临时重定向。")]),t._v(" 该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。 307 会遵守浏览器标准，"),s("strong",[t._v("不会从 POST 变成 GET")]),t._v("。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。"),s("strong",[t._v("规范要求浏览器继续向 Location 的地址 POST 内容")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_4xx-client-error-客户端错误状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4xx-client-error-客户端错误状态码"}},[t._v("#")]),t._v(" 4XX (Client Error 客户端错误状态码)")]),t._v(" "),s("p",[t._v("4XX 的响应结果表明客户端是发生错误的原因所在。")]),t._v(" "),s("h4",{attrs:{id:"_400-bad-request"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_400-bad-request"}},[t._v("#")]),t._v(" 400 Bad Request")]),t._v(" "),s("p",[t._v("该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。")]),t._v(" "),s("h4",{attrs:{id:"_401-unauthorized"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_401-unauthorized"}},[t._v("#")]),t._v(" 401 Unauthorized")]),t._v(" "),s("p",[t._v("该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败 返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。 以下情况会出现401：")]),t._v(" "),s("ul",[s("li",[t._v("401.1 - 登录失败。")]),t._v(" "),s("li",[t._v("401.2 - 服务器配置导致登录失败。")]),t._v(" "),s("li",[t._v("401.3 - 由于 ACL 对资源的限制而未获得授权。")]),t._v(" "),s("li",[t._v("401.4 - 筛选器授权失败。")]),t._v(" "),s("li",[t._v("401.5 - ISAPI/CGI 应用程序授权失败。")]),t._v(" "),s("li",[t._v("401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。")])]),t._v(" "),s("h4",{attrs:{id:"_403-forbidden"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_403-forbidden"}},[t._v("#")]),t._v(" 403 Forbidden")]),t._v(" "),s("p",[t._v("该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。 IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：")]),t._v(" "),s("ul",[s("li",[t._v("403.1 - 执行访问被禁止。")]),t._v(" "),s("li",[t._v("403.2 - 读访问被禁止。")]),t._v(" "),s("li",[t._v("403.3 - 写访问被禁止。")]),t._v(" "),s("li",[t._v("403.4 - 要求 SSL。")]),t._v(" "),s("li",[t._v("403.5 - 要求 SSL 128。")]),t._v(" "),s("li",[t._v("403.6 - IP 地址被拒绝。")]),t._v(" "),s("li",[t._v("403.7 - 要求客户端证书。")]),t._v(" "),s("li",[t._v("403.8 - 站点访问被拒绝。")]),t._v(" "),s("li",[t._v("403.9 - 用户数过多。")]),t._v(" "),s("li",[t._v("403.10 - 配置无效。")]),t._v(" "),s("li",[t._v("403.11 - 密码更改。")]),t._v(" "),s("li",[t._v("403.12 - 拒绝访问映射表。")]),t._v(" "),s("li",[t._v("403.13 - 客户端证书被吊销。")]),t._v(" "),s("li",[t._v("403.14 - 拒绝目录列表。")]),t._v(" "),s("li",[t._v("403.15 - 超出客户端访问许可。")]),t._v(" "),s("li",[t._v("403.16 - 客户端证书不受信任或无效。")]),t._v(" "),s("li",[t._v("403.17 - 客户端证书已过期或尚未生效")]),t._v(" "),s("li",[t._v("403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。")]),t._v(" "),s("li",[t._v("403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。")]),t._v(" "),s("li",[t._v("403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。")])]),t._v(" "),s("h4",{attrs:{id:"_404-not-found"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_404-not-found"}},[t._v("#")]),t._v(" 404 Not Found")]),t._v(" "),s("p",[t._v("该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。 以下情况会出现404：")]),t._v(" "),s("ul",[s("li",[t._v("404.0 -（无） – 没有找到文件或目录。")]),t._v(" "),s("li",[t._v("404.1 - 无法在所请求的端口上访问 Web 站点。")]),t._v(" "),s("li",[t._v("404.2 - Web 服务扩展锁定策略阻止本请求。")]),t._v(" "),s("li",[t._v("404.3 - MIME 映射策略阻止本请求。")])]),t._v(" "),s("h4",{attrs:{id:"_405-method-not-allowed"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_405-method-not-allowed"}},[t._v("#")]),t._v(" 405 Method Not Allowed")]),t._v(" "),s("p",[t._v("该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。 GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。 客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下")]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("Access"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Control"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Allow"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Methods"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("GET")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("HEAD")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PUT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("PATCH")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("POST")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DELETE")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h3",{attrs:{id:"_5xx-server-error-服务器错误状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5xx-server-error-服务器错误状态码"}},[t._v("#")]),t._v(" 5XX (Server Error 服务器错误状态码)")]),t._v(" "),s("p",[t._v("5XX 的响应结果表明服务器本身发生错误.")]),t._v(" "),s("h4",{attrs:{id:"_500-internal-server-error"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_500-internal-server-error"}},[t._v("#")]),t._v(" 500 Internal Server Error")]),t._v(" "),s("p",[t._v("该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。")]),t._v(" "),s("h4",{attrs:{id:"_502-bad-gateway"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_502-bad-gateway"}},[t._v("#")]),t._v(" 502 Bad Gateway")]),t._v(" "),s("p",[t._v("该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的 注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复 以下情况会出现502：")]),t._v(" "),s("ul",[s("li",[t._v("502.1 - CGI （通用网关接口）应用程序超时。")]),t._v(" "),s("li",[t._v("502.2 - CGI （通用网关接口）应用程序出错。")])]),t._v(" "),s("h4",{attrs:{id:"_503-service-unavailable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_503-service-unavailable"}},[t._v("#")]),t._v(" 503 Service Unavailable")]),t._v(" "),s("p",[t._v("该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。 "),s("strong",[t._v("使用场景：")])]),t._v(" "),s("ul",[s("li",[t._v("服务器停机维护时，主动用503响应请求；")]),t._v(" "),s("li",[t._v("nginx 设置限速，超过限速，会返回503。")])]),t._v(" "),s("h4",{attrs:{id:"_504-gateway-timeout"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_504-gateway-timeout"}},[t._v("#")]),t._v(" 504 Gateway Timeout")]),t._v(" "),s("p",[t._v("该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。 使用场景：代码执行时间超时，或者发生了死循环。")]),t._v(" "),s("h3",{attrs:{id:"补充400和401、403状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#补充400和401、403状态码"}},[t._v("#")]),t._v(" 补充400和401、403状态码")]),t._v(" "),s("p",[s("strong",[t._v("400状态码：请求无效")])]),t._v(" "),s("p",[t._v("产生原因：")]),t._v(" "),s("ul",[s("li",[t._v("前端提交数据的字段名称和字段类型与后台的实体没有保持一致")]),t._v(" "),s("li",[t._v("前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。")])]),t._v(" "),s("p",[t._v("解决方法：")]),t._v(" "),s("ul",[s("li",[t._v("对照字段的名称，保持一致性")]),t._v(" "),s("li",[t._v("将obj对象通过JSON.stringify实现序列化")])]),t._v(" "),s("p",[s("strong",[t._v("401状态码：当前请求需要用户验证")])]),t._v(" "),s("p",[s("strong",[t._v("403状态码：服务器已经得到请求，但是拒绝执行")])]),t._v(" "),s("h3",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);v.default=a.exports}}]);