(window.webpackJsonp=window.webpackJsonp||[]).push([[514],{2269:function(n,s,e){"use strict";e.r(s);var a=e(14),t=Object(a.a)({},(function(){var n=this,s=n.$createElement,e=n._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h3",{attrs:{id:"微前端解决方案-qiankun-js沙箱的原理-样式隔离的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#微前端解决方案-qiankun-js沙箱的原理-样式隔离的原理"}},[n._v("#")]),n._v(" 微前端解决方案 qiankun？JS沙箱的原理？样式隔离的原理？")]),n._v(" "),e("ol",[e("li",[n._v("qiankun 是基于 single-spa 封装的，提供了更加开箱即用的 API，使得微应用的接入像使用 iframe 一样简单，实现把应用改造的工作量降到最低。并且主应用和微应用都是技术栈无关的，解决了开发中的两个问题：第一是空间上不同团队的协同开发不必统一技术栈，第二是时间上不同版本技术栈的升级维护无需统一。因此"),e("strong",[n._v("技术栈无关")]),n._v("是微前端的核心价值。")]),n._v(" "),e("li",[n._v("JS 沙箱：")])]),n._v(" "),e("ul",[e("li",[e("p",[e("strong",[n._v("快照沙箱(snapshotSandbox)")]),n._v("：在应用沙箱挂载和卸载的时候记录快照，在应用切换的时候依据快照恢复环境。qiankun 的快照沙箱是基于 "),e("code",[n._v("diff")]),n._v(" 来实现的，主要用于不支持 "),e("code",[n._v("window.Proxy")]),n._v(" 的低版本浏览器，而且也只适合单个实例的子应用，且会污染全局 "),e("code",[n._v("window")]),n._v("。")])]),n._v(" "),e("li",[e("p",[n._v("代理沙箱(proxySandbox)")]),n._v(" "),e("p",[n._v("：qiankun 基于 es6 的")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("Proxy\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br")])]),e("p",[n._v("实现了两种应用场景不同的沙箱，一种是")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("legacySandbox\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br")])]),e("p",[n._v("(单例)，一种是")]),n._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("proxySandbox\n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br")])]),e("p",[n._v("(多例)。因为都是基于 Proxy 实现的，所以都称为代理沙箱。")]),n._v(" "),e("ul",[e("li",[e("strong",[n._v("单例沙箱(legacySandbox)")]),n._v("：同样会对 "),e("code",[n._v("window")]),n._v(" 造成污染，但是性能比快照沙箱好，不用遍历 "),e("code",[n._v("window")]),n._v(" 对象。")]),n._v(" "),e("li",[e("strong",[n._v("多例沙箱(proxySandbox)")]),n._v("：不会污染全局 "),e("code",[n._v("window")]),n._v(" 并支持多个子应用同时加载。")])])])]),n._v(" "),e("ol",[e("li",[n._v("样式隔离：微前端框架里面可能会遇到的样式冲突有两种，一种是主子应用样式冲突，另一种是子应用之间的应用冲突。")])]),n._v(" "),e("ul",[e("li",[e("strong",[n._v("动态样式表(Dynamic Stylesheet)")]),n._v("：qiankun 自动实现子应用切换时子应用样式动态切换，能够保证你在单应用模式下（就是同时只能有一个应用活跃的情况下）保证子应用和子应用之间的样式不会冲突。")]),n._v(" "),e("li",[e("strong",[n._v("工程化手段(css module)")]),n._v("：可以通过手动的方式确保主应用与微应用之间的样式隔离，比如给主应用的所有样式添加一个前缀（或者使用库）；也可以通过配置 "),e("code",[n._v("{ sandbox : { experimentalStyleIsolation: true } }")]),n._v(" 的方式开启运行时的 scoped css 功能，从而解决应用间的样式隔离问题。")]),n._v(" "),e("li",[e("strong",[n._v("严格样式隔离(Shadow DOM)")]),n._v("：默认情况下沙箱可以确保单实例场景子应用之间的样式隔离，但是无法确保主应用跟子应用、或者多实例场景的子应用样式隔离。当配置为 "),e("code",[n._v("{ strictStyleIsolation: true }")]),n._v(" 时表示开启严格的样式隔离模式。这种模式下 qiankun 会为每个微应用的容器包裹上一个 "),e("code",[n._v("shadow dom")]),n._v(" 节点，从而确保微应用的样式不会对全局造成影响。（但是使用时还是要适配和考虑特殊情况）")])])])}),[],!1,null,null,null);s.default=t.exports}}]);