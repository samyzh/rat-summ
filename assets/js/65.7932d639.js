(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{1587:function(t,a,s){t.exports=s.p+"assets/img/169b42c3abe78a05.96cc259e.png"},1588:function(t,a,s){t.exports=s.p+"assets/img/169b42c3b5c6759a.c47d6bf1.png"},1589:function(t,a,s){t.exports=s.p+"assets/img/169b42c3b5163360.c20d7dd5.png"},1590:function(t,a,s){t.exports=s.p+"assets/img/e0beb3bfb8634750b8676606d07294b1~tplv-k3u1fbpfcp-zoom-1.15fa1400.png"},1591:function(t,a,s){t.exports=s.p+"assets/img/1f8e74d36a7f431cb3a2e586c05b9e61~tplv-k3u1fbpfcp-zoom-1.1b0f7b2a.png"},1592:function(t,a,s){t.exports=s.p+"assets/img/react生命周期new.a8766f0b.png"},2261:function(t,a,s){"use strict";s.r(a);var r=s(14),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"虚拟dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),r("h3",{attrs:{id:"简述一下virtual-dom-如何工作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简述一下virtual-dom-如何工作"}},[t._v("#")]),t._v(" 简述一下virtual DOM 如何工作？")]),t._v(" "),r("ul",[r("li",[t._v("当数据发生变化，比如setState时，会引起组件重新渲染，整个UI都会以virtual dom的形式重新渲染")]),t._v(" "),r("li",[t._v("然后"),r("strong",[t._v("收集差异")]),t._v("也就是diff新的virtual dom和老的virtual dom的差异")]),t._v(" "),r("li",[t._v("最后"),r("strong",[t._v("把差异队列里的差异，比如增加节点、删除节点、移动节点更新到真实的DOM上")])])]),t._v(" "),r("h3",{attrs:{id:"什么是虚拟-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟-dom"}},[t._v("#")]),t._v(" 什么是虚拟 DOM？")]),t._v(" "),r("p",[t._v("虚拟 DOM 是组成应用程序用户界面的实际HTML元素的内存表示形式。重新渲染组件时，虚拟 DOM 会将更改与其 DOM 模型进行比较，以创建要应用的更新列表。"),r("strong",[t._v("主要优点是它高效，仅需对实际 DOM 进行最小限度的更改，而不必重新渲染大块")])]),t._v(" "),r("h3",{attrs:{id:"你了解-virtual-dom-吗-解释一下它的工作原理。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#你了解-virtual-dom-吗-解释一下它的工作原理。"}},[t._v("#")]),t._v(" "),r("strong",[t._v("你了解 Virtual DOM 吗？解释一下它的工作原理。")])]),t._v(" "),r("p",[t._v("Virtual DOM 是一个轻量级的 JavaScript 对象，它最初只是 real DOM 的副本。它是一个节点树，它将元素、它们的属性和内容作为对象及其属性。 React 的渲染函数从 React 组件中创建一个节点树。然后它响应数据模型中的变化来更新该树，该变化是由用户或系统完成的各种动作引起的。")]),t._v(" "),r("p",[t._v("Virtual DOM 工作过程有三个简单的步骤。")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("每当底层数据发生改变时，整个 UI 都将在 Virtual DOM 描述中重新渲染。")]),t._v(" "),r("p",[r("img",{attrs:{src:s(1587),alt:"Virtual DOM 1"}})])]),t._v(" "),r("li",[r("p",[t._v("然后计算之前 DOM 表示与新表示的之间的差异。")]),t._v(" "),r("p",[r("img",{attrs:{src:s(1588),alt:"Virtual DOM 2"}})])]),t._v(" "),r("li",[r("p",[t._v("完成计算后，将只用实际更改的内容更新 real DOM。")]),t._v(" "),r("p",[r("img",{attrs:{src:s(1589),alt:"Virtual DOM 3"}})])])]),t._v(" "),r("h3",{attrs:{id:"虚拟dom实现原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom实现原理"}},[t._v("#")]),t._v(" 虚拟DOM实现原理?")]),t._v(" "),r("ul",[r("li",[t._v("虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象")]),t._v(" "),r("li",[t._v("状态变更时，记录新树和旧树的差异")]),t._v(" "),r("li",[t._v("最后把差异更新到真正的dom中")])]),t._v(" "),r("h3",{attrs:{id:"区分real-dom和virtual-dom"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#区分real-dom和virtual-dom"}},[t._v("#")]),t._v(" "),r("strong",[t._v("区分Real DOM和Virtual DOM")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[r("strong",[t._v("Real DOM")])]),t._v(" "),r("th",[r("strong",[t._v("Virtual  DOM")])])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("1. 更新缓慢。")]),t._v(" "),r("td",[t._v("1. 更新更快。")])]),t._v(" "),r("tr",[r("td",[t._v("2. 可以直接更新 HTML。")]),t._v(" "),r("td",[t._v("2. 无法直接更新 HTML。")])]),t._v(" "),r("tr",[r("td",[t._v("3. 如果元素更新，则创建新DOM。")]),t._v(" "),r("td",[t._v("3. 如果元素更新，则更新 JSX 。")])]),t._v(" "),r("tr",[r("td",[t._v("4. DOM操作代价很高。")]),t._v(" "),r("td",[t._v("4. DOM 操作非常简单。")])]),t._v(" "),r("tr",[r("td",[t._v("5. 消耗的内存较多。")]),t._v(" "),r("td",[t._v("5. 很少的内存消耗。")])])])]),t._v(" "),r("h3",{attrs:{id:"对虚拟-dom-的理解-虚拟-dom-主要做了什么-虚拟-dom-本身是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对虚拟-dom-的理解-虚拟-dom-主要做了什么-虚拟-dom-本身是什么"}},[t._v("#")]),t._v(" 对虚拟 DOM 的理解？虚拟 DOM 主要做了什么？虚拟 DOM 本身是什么？")]),t._v(" "),r("p",[t._v("从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。")]),t._v(" "),r("p",[t._v("虚拟dom是对DOM的抽象，这个对象是更加轻量级的对DOM的描述。它设计的最初目的，就是更好的跨平台，比如node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟dom，因为虚拟dom本身是js对象。 在代码渲染到页面之前，vue或者react会把代码转换成一个对象（虚拟DOM）。以对象的形式来描述真实dom结构，最终渲染到页面。在每次数据发生变化前，虚拟dom都会缓存一份，变化之时，现在的虚拟dom会与缓存的虚拟dom进行比较。在vue或者react内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。")]),t._v(" "),r("p",[t._v("另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。")]),t._v(" "),r("p",[r("strong",[t._v("为什么要用 Virtual DOM：")])]),t._v(" "),r("p",[r("strong",[t._v("（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能")]),t._v(" 下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("真实DOM∶ 生成HTML字符串＋ 重建所有的DOM元素")])]),t._v(" "),r("li",[r("strong",[t._v("Virtual DOM∶ 生成vNode＋ DOMDiff＋必要的dom更新")])])]),t._v(" "),r("p",[t._v("Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，我依然可以给你提供过得去的性能。")]),t._v(" "),r("p",[r("strong",[t._v("（2）跨平台")]),t._v(" Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。")]),t._v(" "),r("h3",{attrs:{id:"react-diff-原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-diff-原理"}},[t._v("#")]),t._v(" React diff 原理")]),t._v(" "),r("ul",[r("li",[t._v("把树形结构按照层级分解，只比较同级元素。")]),t._v(" "),r("li",[t._v("列表结构的每个单元添加唯一的 key 属性，方便比较。")]),t._v(" "),r("li",[t._v("React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）")]),t._v(" "),r("li",[t._v("合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.")]),t._v(" "),r("li",[t._v("选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。")])]),t._v(" "),r("h3",{attrs:{id:"react-diff-算法的原理是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-diff-算法的原理是什么"}},[t._v("#")]),t._v(" React diff 算法的原理是什么？")]),t._v(" "),r("p",[t._v("实际上，diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新。 "),r("img",{attrs:{src:s(1590),alt:"在这里插入图片描述"}})]),t._v(" "),r("p",[t._v("具体的流程如下：")]),t._v(" "),r("ul",[r("li",[t._v("真实的 DOM 首先会映射为虚拟 DOM；")]),t._v(" "),r("li",[t._v("当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；")]),t._v(" "),r("li",[t._v("根据 patch 去更新真实的 DOM，反馈到用户的界面上。")])]),t._v(" "),r("p",[r("img",{attrs:{src:s(1591),alt:"在这里插入图片描述"}})]),t._v(" "),r("p",[t._v("一个简单的例子：")]),t._v(" "),r("div",{staticClass:"language-javascript line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" React "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react'")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExampleComponent")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("isVisible"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n       "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div className"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"visible"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("visbile"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n     "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div className"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hidden"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("hidden"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br"),r("span",{staticClass:"line-number"},[t._v("8")]),r("br"),r("span",{staticClass:"line-number"},[t._v("9")]),r("br")])]),r("p",[t._v("这里，首先假定 ExampleComponent 可见，然后再改变它的状态，让它不可见 。映射为真实的 DOM 操作是这样的，React 会创建一个 div 节点。")]),t._v(" "),r("div",{staticClass:"language-javascript line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"visible"')]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("visbile"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br")])]),r("p",[t._v("当把 visbile 的值变为 false 时，就会替换 class 属性为 hidden，并重写内部的 innerText 为 hidden。"),r("strong",[t._v("这样一个生成补丁、更新差异的过程统称为 diff 算法。")])]),t._v(" "),r("p",[t._v("diff算法可以总结为三个策略，分别从树、组件及元素三个层面进行复杂度的优化： "),r("strong",[t._v("策略一：忽略节点跨层级操作场景，提升比对效率。（基于树进行对比）")]),t._v(" 这一策略需要进行树比对，即对树进行分层比较。树比对的处理手法是非常“暴力”的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。")]),t._v(" "),r("p",[r("strong",[t._v("策略二：如果组件的 class 一致，则默认为相似的树结构，否则默认为不同的树结构。（基于组件进行对比）")]),t._v(" 在组件比对的过程中：")]),t._v(" "),r("ul",[r("li",[t._v("如果组件是同一类型则进行树比对；")]),t._v(" "),r("li",[t._v("如果不是则直接放入补丁中。")])]),t._v(" "),r("p",[t._v("只要父组件类型不同，就会被重新渲染。这也就是为什么 shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。")]),t._v(" "),r("p",[r("strong",[t._v("策略三：同一层级的子节点，可以通过标记 key 的方式进行列表对比。（基于节点进行对比）")]),t._v(" 元素比对主要发生在同层级中，通过标记节点操作生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。")]),t._v(" "),r("h3",{attrs:{id:"react-key-是干嘛用的-为什么要加-key-主要是解决哪一类问题的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-key-是干嘛用的-为什么要加-key-主要是解决哪一类问题的"}},[t._v("#")]),t._v(" React key 是干嘛用的 为什么要加？key 主要是解决哪一类问题的")]),t._v(" "),r("p",[t._v("Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。")]),t._v(" "),r("p",[t._v("在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系")]),t._v(" "),r("p",[t._v("注意事项：")]),t._v(" "),r("ul",[r("li",[t._v("key值一定要和具体的元素—一对应到")]),t._v(" "),r("li",[t._v("尽量不要用数组的index去作为key。")]),t._v(" "),r("li",[t._v("永远不要试图在render的时候用随机数或者其他操作给元素加上不稳定的key，这样造成的性能开销比不加key的情况下更糟糕。")])]),t._v(" "),r("h3",{attrs:{id:"虚拟-dom-的引入与直接操作原生-dom-相比-哪一个效率更高-为什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-的引入与直接操作原生-dom-相比-哪一个效率更高-为什么"}},[t._v("#")]),t._v(" 虚拟 DOM 的引入与直接操作原生 DOM 相比，哪一个效率更高，为什么")]),t._v(" "),r("p",[t._v("虚拟DOM相对原生的DOM不一定是效率更高，如果只修改一个按钮的文案，那么虚拟 DOM 的操作无论如何都不可能比真实的 DOM 操作更快。在首次渲染大量DOM时，由于多了一层虚拟DOM的计算，虚拟DOM也会比innerHTML插入慢。它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。所以一定要根据具体的场景进行探讨。")]),t._v(" "),r("p",[t._v("在整个 DOM 操作的演化过程中，其实主要矛盾并不在于性能，而在于开发者写得爽不爽，在于研发体验/研发效率。虚拟 DOM 不是别的，正是前端开发们为了追求更好的研发体验和研发效率而创造出来的高阶产物。虚拟 DOM 并不一定会带来更好的性能，React 官方也从来没有把虚拟 DOM 作为性能层面的卖点对外输出过。"),r("strong",[t._v("虚拟 DOM 的优越之处在于，它能够在提供更爽、更高效的研发模式（也就是函数式的 UI 编程方式）的同时，仍然保持一个还不错的性能。")])]),t._v(" "),r("h3",{attrs:{id:"react-与-vue-的-diff-算法有何不同"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-与-vue-的-diff-算法有何不同"}},[t._v("#")]),t._v(" React 与 Vue 的 diff 算法有何不同？")]),t._v(" "),r("p",[t._v("diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程："),r("strong",[t._v("触发更新 → 生成补丁 → 应用补丁")]),t._v("。")]),t._v(" "),r("p",[t._v("React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，"),r("strong",[t._v("采用了深度优先遍历算法")]),t._v("。但传统的遍历方式，效率较低。"),r("strong",[t._v("为了优化效率，使用了分治的方式")]),t._v("。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("树比对")]),t._v("：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。")]),t._v(" "),r("li",[r("strong",[t._v("组件比对")]),t._v("：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。")]),t._v(" "),r("li",[r("strong",[t._v("元素比对")]),t._v("：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。")])]),t._v(" "),r("p",[r("strong",[t._v("以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构")]),t._v("。为了使整个更新过程可随时暂停恢复，"),r("strong",[t._v("节点与树分别采用了 FiberNode 与 FiberTree 进行重构")]),t._v("。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。")]),t._v(" "),r("p",[t._v("Vue 的整体 diff 策略与 React 对齐，"),r("strong",[t._v("虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差")]),t._v("，")]),t._v(" "),r("p",[t._v("因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。"),r("strong",[t._v("除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。")])]),t._v(" "),r("h3",{attrs:{id:"为什么虚拟-dom-会提高性能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么虚拟-dom-会提高性能"}},[t._v("#")]),t._v(" 为什么虚拟 dom 会提高性能?")]),t._v(" "),r("ul",[r("li",[t._v("虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。")]),t._v(" "),r("li",[t._v("用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。")])]),t._v(" "),r("h3",{attrs:{id:"虚拟dom的优劣如何"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom的优劣如何"}},[t._v("#")]),t._v(" 虚拟DOM的优劣如何?")]),t._v(" "),r("p",[t._v("优点:")]),t._v(" "),r("ul",[r("li",[t._v("保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限")]),t._v(" "),r("li",[t._v("无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率")]),t._v(" "),r("li",[t._v("跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等")])]),t._v(" "),r("p",[t._v("缺点:")]),t._v(" "),r("ul",[r("li",[t._v("无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化,比如VScode采用直接手动操作DOM的方式进行极端的性能优化")])]),t._v(" "),r("h2",{attrs:{id:"react16"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react16"}},[t._v("#")]),t._v(" React16")]),t._v(" "),r("h3",{attrs:{id:"react-最新版本解决了什么问题-增加了哪些东西"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-最新版本解决了什么问题-增加了哪些东西"}},[t._v("#")]),t._v(" react 最新版本解决了什么问题，增加了哪些东西")]),t._v(" "),r("p",[t._v("React 16.x的"),r("strong",[t._v("三大新特性 Time Slicing、Suspense、 hooks")])]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("Time Slicing（解决CPU速度问题")]),t._v("）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得react能在性能极其差的机器跑时，仍然保持有良好的性能；")]),t._v(" "),r("li",[r("strong",[t._v("Suspense （解决网络IO问题）")]),t._v(" 和lazy配合，实现异步加载组件。 能暂停当前组件的渲染， 当完成某件事以后再继续渲染，解决从react出生到现在都存在的「异步副作用」的问题，而且解决得非的优雅，使用的是 T异步但是同步的写法，这是最好的解决异步问题的方式；")]),t._v(" "),r("li",[t._v("提供了一个"),r("strong",[t._v("内置函数componentDidCatch")]),t._v("，当有错误发生时，可以友好地展示 fallback 组件; 可以捕捉到它的子元素（包括嵌套子元素）抛出的异常; 可以复用错误组件；")])]),t._v(" "),r("p",[r("strong",[t._v("（1）React16.8")]),t._v(" 加入hooks，让React函数式组件更加灵活，hooks之前，React存在很多问题：")]),t._v(" "),r("ul",[r("li",[t._v("在组件间复用状态逻辑很难；")]),t._v(" "),r("li",[t._v("复杂组件变得难以理解，高阶组件和函数组件的嵌套过深；")]),t._v(" "),r("li",[t._v("class组件的this指向问题；")]),t._v(" "),r("li",[t._v("难以记忆的生命周期；")])]),t._v(" "),r("p",[t._v("hooks很好的解决了上述问题，hooks提供了很多方法")]),t._v(" "),r("ul",[r("li",[t._v("useState 返回有状态值，以及更新这个状态值的函数")]),t._v(" "),r("li",[t._v("useEffect 接受包含命令式，可能有副作用代码的函数。")]),t._v(" "),r("li",[t._v("useContext 接受上下文对象（从 React.createContext返回的值）并返回当前上下文值，")]),t._v(" "),r("li",[t._v("useReducer useState 的替代方案。接受类型为 （state，action）=> newState的reducer，并返回与dispatch方法配对的当前状态。")]),t._v(" "),r("li",[t._v("useCalLback 返回一个回忆的memoized版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性 o useMemo 纯的一个记忆函数 o useRef 返回一个可变的ref对象，其Current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。")]),t._v(" "),r("li",[t._v("useImperativeMethods 自定义使用ref时公开给父组件的实例值")]),t._v(" "),r("li",[t._v("useMutationEffect 更新兄弟组件之前，它在React执行其DOM改变的同一阶段同步触发")]),t._v(" "),r("li",[t._v("useLayoutEffect DOM改变后同步触发。使用它来从DOM读取布局并同步重新渲染")])]),t._v(" "),r("p",[r("strong",[t._v("（2）React16.9")])]),t._v(" "),r("ul",[r("li",[t._v("重命名 Unsafe 的生命周期方法。新的 UNSAFE_前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出")]),t._v(" "),r("li",[t._v("废弃 javascrip:形式的 URL。以javascript:开头的URL 非常容易遭受攻击，造成安全漏洞。")]),t._v(" "),r("li",[t._v('废弃"Factory"组件。 工厂组件会导致 React 变大且变慢。')]),t._v(" "),r("li",[t._v("act（）也支持异步函数，并且你可以在调用它时使用 await。")]),t._v(" "),r("li",[t._v("使用 <React.ProfiLer> 进行性能评估。在较大的应用中追踪性能回归可能会很方便")])]),t._v(" "),r("p",[r("strong",[t._v("（3）React16.13.0")])]),t._v(" "),r("ul",[r("li",[t._v("支持在渲染期间调用setState，但仅适用于同一组件")]),t._v(" "),r("li",[t._v("可检测冲突的样式规则并记录警告")]),t._v(" "),r("li",[t._v("废弃 unstable_createPortal，使用CreatePortal")]),t._v(" "),r("li",[t._v("将组件堆栈添加到其开发警告中，使开发人员能够隔离bug并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。")])]),t._v(" "),r("h3",{attrs:{id:"react16的错误边界-error-boundaries-是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react16的错误边界-error-boundaries-是什么"}},[t._v("#")]),t._v(" react16的错误边界（Error Boundaries）是什么")]),t._v(" "),r("p",[r("strong",[t._v("部分 UI 中的 JavaScript 错误不应该破坏整个应用程序")]),t._v("。 为了解决 React 用户的这个问题，React 16引入了一个 “错误边界(Error Boundaries)” 的新概念。")]),t._v(" "),r("div",{staticClass:"language-js line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" React "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react'")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" ReactDOM "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react-dom'")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ErrorBoundary")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("constructor")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("props")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("props"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("hasError"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),r("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("componentDidCatch")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("err"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("info")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("setState")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("hasError"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("hasError"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("h1"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("Something Went Wrong"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("h1"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("children"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Page")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n            "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ErrorBoundary"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n                "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Clock"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n            "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ErrorBoundary"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Clock")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("React"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Component")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n            "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("hello"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("toString")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n        "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nReactDOM"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Page"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("document"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("querySelector")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#root'")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br"),r("span",{staticClass:"line-number"},[t._v("7")]),r("br"),r("span",{staticClass:"line-number"},[t._v("8")]),r("br"),r("span",{staticClass:"line-number"},[t._v("9")]),r("br"),r("span",{staticClass:"line-number"},[t._v("10")]),r("br"),r("span",{staticClass:"line-number"},[t._v("11")]),r("br"),r("span",{staticClass:"line-number"},[t._v("12")]),r("br"),r("span",{staticClass:"line-number"},[t._v("13")]),r("br"),r("span",{staticClass:"line-number"},[t._v("14")]),r("br"),r("span",{staticClass:"line-number"},[t._v("15")]),r("br"),r("span",{staticClass:"line-number"},[t._v("16")]),r("br"),r("span",{staticClass:"line-number"},[t._v("17")]),r("br"),r("span",{staticClass:"line-number"},[t._v("18")]),r("br"),r("span",{staticClass:"line-number"},[t._v("19")]),r("br"),r("span",{staticClass:"line-number"},[t._v("20")]),r("br"),r("span",{staticClass:"line-number"},[t._v("21")]),r("br"),r("span",{staticClass:"line-number"},[t._v("22")]),r("br"),r("span",{staticClass:"line-number"},[t._v("23")]),r("br"),r("span",{staticClass:"line-number"},[t._v("24")]),r("br"),r("span",{staticClass:"line-number"},[t._v("25")]),r("br"),r("span",{staticClass:"line-number"},[t._v("26")]),r("br"),r("span",{staticClass:"line-number"},[t._v("27")]),r("br"),r("span",{staticClass:"line-number"},[t._v("28")]),r("br"),r("span",{staticClass:"line-number"},[t._v("29")]),r("br"),r("span",{staticClass:"line-number"},[t._v("30")]),r("br"),r("span",{staticClass:"line-number"},[t._v("31")]),r("br"),r("span",{staticClass:"line-number"},[t._v("32")]),r("br"),r("span",{staticClass:"line-number"},[t._v("33")]),r("br"),r("span",{staticClass:"line-number"},[t._v("34")]),r("br"),r("span",{staticClass:"line-number"},[t._v("35")]),r("br"),r("span",{staticClass:"line-number"},[t._v("36")]),r("br")])]),r("h3",{attrs:{id:"react16版本的reconciliation阶段和commit阶段是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react16版本的reconciliation阶段和commit阶段是什么"}},[t._v("#")]),t._v(" react16版本的reconciliation阶段和commit阶段是什么")]),t._v(" "),r("ul",[r("li",[t._v("reconciliation阶段包含的主要工作是对current tree 和 new tree 做diff计算，找出变化部分。进行遍历、对比等是可以中断，歇一会儿接着再来。")]),t._v(" "),r("li",[t._v("commit阶段是对上一阶段获取到的变化部分应用到真实的DOM树中，是一系列的DOM操作。不仅要维护更复杂的DOM状态，而且中断后再继续，会对用户体验造成影响。在普遍的应用场景下，此阶段的耗时比diff计算等耗时相对短。")])]),t._v(" "),r("h2",{attrs:{id:"fiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[t._v("#")]),t._v(" Fiber")]),t._v(" "),r("h3",{attrs:{id:"你对fiber架构了解吗"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#你对fiber架构了解吗"}},[t._v("#")]),t._v(" 你对Fiber架构了解吗")]),t._v(" "),r("p",[t._v("注：答案参考司徒正美大神的文章")]),t._v(" "),r("h3",{attrs:{id:"什么是-react-fiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是-react-fiber"}},[t._v("#")]),t._v(" 什么是 React Fiber?")]),t._v(" "),r("p",[r("strong",[t._v("Fiber")]),t._v(" 是 React 16 中新的协调引擎或重新实现核心算法。"),r("strong",[t._v("它的主要目标是支持虚拟DOM的增量渲染")]),t._v("。"),r("strong",[t._v("React Fiber")]),t._v(" 的目标是"),r("strong",[t._v("提高其在动画、布局、手势、暂停、中止或重用等方面的适用性，并为不同类型的更新分配优先级，以及新的并发原语")]),t._v("。")]),t._v(" "),r("p",[t._v("React Fiber 的目标是增强其在动画、布局和手势等领域的适用性。"),r("strong",[t._v("它的主要特性是增量渲染:能够将渲染工作分割成块，并将其分散到多个帧中")]),t._v("。")]),t._v(" "),r("h3",{attrs:{id:"fiber架构相对于以前的递归更新组件有有什么优势"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber架构相对于以前的递归更新组件有有什么优势"}},[t._v("#")]),t._v(" Fiber架构相对于以前的递归更新组件有有什么优势")]),t._v(" "),r("ul",[r("li",[t._v("原因是"),r("strong",[t._v("递归更新组件会让JS调用栈占用很长时间")]),t._v("。")]),t._v(" "),r("li",[t._v("因为浏览器是单线程的，它将GUI渲染，事件处理,js执行等等放在了一起，只有将它做完才能做下一件事，如果有足够的时间，浏览器是会对我们的代码进行编译优化（JIT）及进行热代码优化。")]),t._v(" "),r("li",[t._v("Fiber架构正是"),r("strong",[t._v("利用这个原理将组件渲染分段执行，提高这样浏览器就有时间优化JS代码与修正reflow")]),t._v("！")])]),t._v(" "),r("h3",{attrs:{id:"既然你说fiber是将组件分段渲染-那第一段渲染之后-怎么知道下一段从哪个组件开始渲染呢"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#既然你说fiber是将组件分段渲染-那第一段渲染之后-怎么知道下一段从哪个组件开始渲染呢"}},[t._v("#")]),t._v(" 既然你说Fiber是将组件分段渲染，那第一段渲染之后，怎么知道下一段从哪个组件开始渲染呢？")]),t._v(" "),r("ul",[r("li",[t._v("Fiber节点拥有return, child, sibling三个属性，分别对应父节点， 第一个孩子， 它右边的兄弟， "),r("strong",[t._v("有了它们就足够将一棵树变成一个链表， 实现深度优化遍历")]),t._v("。")])]),t._v(" "),r("h3",{attrs:{id:"怎么决定每次更新的数量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#怎么决定每次更新的数量"}},[t._v("#")]),t._v(" 怎么决定每次更新的数量")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("React16则是需要将虚拟DOM转换为Fiber节点")]),t._v("，首先它"),r("strong",[t._v("规定一个时间段内，然后在这个时间段能转换多少个FiberNode，就更新多少个。")])]),t._v(" "),r("li",[t._v("因此我们需要将我们的更新逻辑分成两个阶段，"),r("strong",[t._v("第一个阶段是将虚拟DOM转换成Fiber, Fiber转换成组件实例或真实DOM（不插入DOM树，插入DOM树会reflow")]),t._v("）。Fiber转换成后两者明显会耗时，需要计算还剩下多少时间。")]),t._v(" "),r("li",[t._v("比如，可以记录开始更新视图的时间"),r("strong",[t._v("var now = new Date - 0")]),t._v("，假如我们更新试图自定义需要100毫秒，那么定义结束时间是"),r("strong",[t._v("var deadline = new Date + 100")]),t._v(" ,所以每次更新一部分视图，就去拿当前时间new Date<deadline做判断，"),r("strong",[t._v("如果没有超过deadline就更新视图，超过了，就进入下一个更新阶段")])])]),t._v(" "),r("h3",{attrs:{id:"如何调度时间才能保证流畅"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何调度时间才能保证流畅"}},[t._v("#")]),t._v(" 如何调度时间才能保证流畅")]),t._v(" "),r("ul",[r("li",[t._v("使用浏览器自带的api - requestIdleCallback，")]),t._v(" "),r("li",[t._v("它的第一个参数是一个回调，回调有一个参数对象，对象有一个timeRemaining方法，就相当于new Date - deadline，并且它是一个高精度数据， 比毫秒更准确")]),t._v(" "),r("li",[r("strong",[t._v("这个因为浏览器兼容性问题，react团队自己实现了requestIdleCallback")]),t._v("【RIC】")])]),t._v(" "),r("h3",{attrs:{id:"fiber带来的新的生命周期是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber带来的新的生命周期是什么"}},[t._v("#")]),t._v(" fiber带来的新的生命周期是什么")]),t._v(" "),r("p",[t._v("React 新版 生命周期")]),t._v(" "),r("p",[r("img",{attrs:{src:s(1592),alt:"react生命周期new"}})]),t._v(" "),r("h4",{attrs:{id:"创建时"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建时"}},[t._v("#")]),t._v(" 创建时")]),t._v(" "),r("ul",[r("li",[t._v("constructor ->")]),t._v(" "),r("li",[t._v("getDerivedStateFromProps(参数nextProps, prevState,注意里面this不指向组件的实例)->")]),t._v(" "),r("li",[t._v("render ->")]),t._v(" "),r("li",[t._v("componentDidMount")])]),t._v(" "),r("h4",{attrs:{id:"更新时"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#更新时"}},[t._v("#")]),t._v(" 更新时")]),t._v(" "),r("ul",[r("li",[t._v("getDerivedStateFromProps(这个时props更新才调用，setState时不调用这个生命周期， 参数nextProps, prevState) ->")]),t._v(" "),r("li",[t._v("shouldComponentUpdate(setState时调用参数nextProps, nextState)->")]),t._v(" "),r("li",[t._v("render->")]),t._v(" "),r("li",[t._v("getSnapsshotBeforeUpdate(替换 componentWillUpdate)")]),t._v(" "),r("li",[t._v("componentDidUpdate(参数prevProps, prevState, snapshot)")])]),t._v(" "),r("h3",{attrs:{id:"你是如何理解fiber的-【要点】"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#你是如何理解fiber的-【要点】"}},[t._v("#")]),t._v(" 你是如何理解fiber的?【要点】")]),t._v(" "),r("p",[t._v("React Fiber 是一种基于浏览器的"),r("strong",[t._v("单线程调度算法")]),t._v(".")]),t._v(" "),r("p",[t._v("React 16之前 ，"),r("code",[t._v("reconcilation")]),t._v(" 算法实际上是递归，想要中断递归是很困难的，React 16 开始使用了循环来代替之前的递归.")]),t._v(" "),r("p",[r("code",[t._v("Fiber")]),t._v("："),r("strong",[t._v("一种将 "),r("code",[t._v("recocilation")]),t._v(" （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。")])]),t._v(" "),r("h3",{attrs:{id:"你对-time-slice的理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#你对-time-slice的理解"}},[t._v("#")]),t._v(" 你对 Time Slice的理解?")]),t._v(" "),r("p",[r("strong",[t._v("时间分片")])]),t._v(" "),r("ul",[r("li",[t._v("React 在渲染（render）的时候，不会阻塞现在的线程")]),t._v(" "),r("li",[t._v("如果你的设备足够快，你会感觉渲染是同步的")]),t._v(" "),r("li",[t._v("如果你设备非常慢，你会感觉还算是灵敏的")]),t._v(" "),r("li",[t._v("虽然是异步渲染，但是你将会看到完整的渲染，而不是一个组件一行行的渲染出来")]),t._v(" "),r("li",[t._v("同样书写组件的方式")])])])}),[],!1,null,null,null);a.default=e.exports}}]);