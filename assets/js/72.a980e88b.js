(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{1103:function(t,v,a){t.exports=a.p+"assets/img/e10d0994dde749209d5955d1f37f1deb~tplv-k3u1fbpfcp-zoom-1.3cf3838a.png"},1104:function(t,v,a){t.exports=a.p+"assets/img/f21e0a0fd42949f8b17375a97c6d9683~tplv-k3u1fbpfcp-zoom-1.5ecdd1fe.png"},1105:function(t,v,a){t.exports=a.p+"assets/img/de99dd3c3d7d40f3a641ebdcd8a88490~tplv-k3u1fbpfcp-zoom-1.397415e8.png"},1106:function(t,v,a){t.exports=a.p+"assets/img/19443ef387fe4bbdb783c893d27e734b~tplv-k3u1fbpfcp-zoom-1.1d2f9911.png"},1107:function(t,v,a){t.exports=a.p+"assets/img/b547b441545f43ea8a4dc1e9d4cd4445~tplv-k3u1fbpfcp-zoom-1.eb7be4c9.png"},2020:function(t,v,a){"use strict";a.r(v);var _=a(14),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),_("blockquote",[_("p",[t._v("微服务是面向服务架构（SOA）的一种变体，把应用程序设计成一系列松耦合的细粒度服务，并通过轻量级的通信协议组织起来")])]),t._v(" "),_("p",[t._v("具体地，将应用构建成一组小型服务。"),_("strong",[t._v("这些服务都能够独立部署、独立扩展，每个服务都具有稳固的模块边界，甚至允许使用不同的编程语言来编写不同服务，也可以由不同的团队来管理；")])]),t._v(" "),_("h3",{attrs:{id:"优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#优势"}},[t._v("#")]),t._v(" 优势")]),t._v(" "),_("ol",[_("li",[t._v("独立技术栈：主框架不限制接入应用的技术栈，每个应用的技术栈选型可以配合业务团队选择；")]),t._v(" "),_("li",[t._v("独立开发、独立部署：子应用仓库独立，前后端可独立开发，部署完成后主框架同步更新子应用；")]),t._v(" "),_("li",[t._v("独立运行：每个子应用之间状态隔离，单独子应用失败不会影响到其他项目；")]),t._v(" "),_("li",[t._v("数据共享：子应用可以共享主应用数据，亦可共享兄弟应用数据；")])]),t._v(" "),_("h3",{attrs:{id:"劣势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#劣势"}},[t._v("#")]),t._v(" 劣势")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("技术团队有没有能力对新架构兜底")]),t._v(" "),_("ul",[_("li",[t._v("独立模块应用"),_("strong",[t._v("独立部署")])]),t._v(" "),_("li",[t._v("多技术栈的接入")]),t._v(" "),_("li",[t._v("解决多应用之间的"),_("strong",[t._v("样式隔离与通用、数据隔离与通信")])]),t._v(" "),_("li",[t._v("多团队开发是否保持正常协作")])])]),t._v(" "),_("li",[_("p",[t._v("业务是否高度集中、庞大到需要拆分独立业务")]),t._v(" "),_("p",[t._v("没有耦合的业务或者过小的业务，走微服务反而是一种负担")])]),t._v(" "),_("li",[_("p",[t._v("团队是否存在多个技术栈，并且不能够统一")]),t._v(" "),_("ul",[_("li",[t._v("没有统一的技术栈，项目基础样式，架构都会存在差异")]),t._v(" "),_("li",[t._v("项目管理交接会存在难度")]),t._v(" "),_("li",[t._v("整体研发成本反而增加")])])])]),t._v(" "),_("h3",{attrs:{id:"接入场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接入场景"}},[t._v("#")]),t._v(" 接入场景")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("项目技术栈过于老旧,相关技能的开发人员少,功能扩展吃力,重构成本高,维护成本高；")]),t._v(" "),_("p",[_("strong",[t._v("通过微服务拆分将项目拆分掉，渐进式重构、重写、迭代后期功能；")])])]),t._v(" "),_("li",[_("p",[t._v("项目过于庞大，开发，部署效率底下，且出现问题，造成全局崩盘，不好维护；")])]),t._v(" "),_("li",[_("p",[t._v("项目组存在不同技术栈，但是需要接入同一套主系统中；")])])]),t._v(" "),_("h3",{attrs:{id:"模式对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模式对比"}},[t._v("#")]),t._v(" 模式对比")]),t._v(" "),_("p",[t._v("微服务简单点来说就是"),_("strong",[t._v("将一个大综合的 Bundle 拆成多个子 Bundles，再通过父级容器加载各个子 Bundle，达到想要的拆包，合包效果；")])]),t._v(" "),_("p",[_("img",{attrs:{src:a(1103),alt:"img"}})]),t._v(" "),_("h3",{attrs:{id:"实现分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现分类"}},[t._v("#")]),t._v(" 实现分类")]),t._v(" "),_("h4",{attrs:{id:"图示分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图示分类"}},[t._v("#")]),t._v(" 图示分类")]),t._v(" "),_("p",[_("img",{attrs:{src:a(1104),alt:"img"}})]),t._v(" "),_("h4",{attrs:{id:"bundle-集成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bundle-集成"}},[t._v("#")]),t._v(" Bundle 集成")]),t._v(" "),_("h5",{attrs:{id:"构建时集成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构建时集成"}},[t._v("#")]),t._v(" 构建时集成")]),t._v(" "),_("ol",[_("li",[t._v("将子应用单独发布 npm 包，以依赖包的形式，引入到主工程")]),t._v(" "),_("li",[t._v("采用 git submodule 的形式，引入主工程")])]),t._v(" "),_("p",[t._v("构建时集成"),_("strong",[t._v("最大的问题是会在发布阶段造成耦合，每一个子版本的修改，都会导致整个工程需要重新编译构建，从能效上考虑")]),t._v("，不是首推选项。优化后可以考虑分包处理方式；")]),t._v(" "),_("h5",{attrs:{id:"运行时集成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行时集成"}},[t._v("#")]),t._v(" 运行时集成")]),t._v(" "),_("p",[_("strong",[t._v("iframe 引用")])]),t._v(" "),_("p",[t._v("优势：iframe 天生自带样式、数据隔离")]),t._v(" "),_("p",[t._v("劣势：原生的隔离性，意味着很难把应用的各个部分联系到一起，路由控制、历史栈管理、深度链接（deep-linking）、响应式布局等都变得异常复杂，因而限制了 iframe 方案的灵活性；")]),t._v(" "),_("blockquote",[_("p",[t._v("老壶新酒，还是很好用的，"),_("strong",[t._v("在超级复杂的且上线时间极短的情况下，直接冲鸭，别犹豫")])])]),t._v(" "),_("p",[_("strong",[t._v("路由 + js bundle")])]),t._v(" "),_("ol",[_("li",[t._v("使用的是 Single—Spa + SystemJS 构建的微服务;")]),t._v(" "),_("li",[t._v("umijs + qiankun 生态圈不错的，react 技术栈的可以考虑下;")])]),t._v(" "),_("p",[_("strong",[t._v("Web Components")])]),t._v(" "),_("p",[t._v("每个子应用封装成自定义 HTML 元素（而不是前端路由方案中的渲染函数），以获得Shadow DOM带来的样式隔离等好处；")]),t._v(" "),_("h2",{attrs:{id:"iframe"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#iframe"}},[t._v("#")]),t._v(" Iframe")]),t._v(" "),_("blockquote",[_("p",[t._v("iFrame 是微前端集成的最简单方式之一。可以说iFrame 里的页面是完全独立的，而且iFrame 页面中的静态资源（js、css）都是相互隔离的，互相不干扰，相当于一个独立的环境，具备沙箱隔离，可以让前端应用之间可以相互独立运行，")]),t._v(" "),_("p",[t._v("但是IFrame局限性也很大，主要包括以下几点👇：")])]),t._v(" "),_("ul",[_("li",[t._v("子项目需调整，需要隐藏自身页面中的导航（公共区域）；")]),t._v(" "),_("li",[t._v("iFrame嵌入的视图控制难，有局限性；")]),t._v(" "),_("li",[t._v("刷新无法保存记录，也就意味着当浏览器刷新状态将消失，后退返回无效")]),t._v(" "),_("li",[t._v("iframe 阻塞主页面加载；")])]),t._v(" "),_("p",[_("img",{attrs:{src:a(1105),alt:"img"}})]),t._v(" "),_("h2",{attrs:{id:"nginx路由分发"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nginx路由分发"}},[t._v("#")]),t._v(" Nginx路由分发")]),t._v(" "),_("blockquote",[_("p",[t._v("通过配置nginx的location来制定不同路由映射的静态资源访问路径，将多个子项目聚合成一体，来配置不同路由的转发代理；")])]),t._v(" "),_("p",[t._v("这种通过nginx路由分发也有局限性：")]),t._v(" "),_("ul",[_("li",[t._v("web应用之间的复用性差，每个应用都是独立的，无法共享数据和资源；")]),t._v(" "),_("li",[t._v("每个独立的项目之间切换，需要重新加载，容易出现白屏影响用户体验；")])]),t._v(" "),_("p",[_("img",{attrs:{src:a(1106),alt:"img"}})]),t._v(" "),_("h2",{attrs:{id:"single-spa"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#single-spa"}},[t._v("#")]),t._v(" Single-spa")]),t._v(" "),_("blockquote",[_("p",[t._v("官方号称“一个用于前端微服务化的JavaScript前端解决方案”，single-spa 听起来很高大上，它能兼容各种技术栈，并且在同一个页面中可以使用多种技术框架(React, Vue, Angular等任意技术框架)，不用考虑因新的技术框架而去重构旧项目的代码")])]),t._v(" "),_("p",[_("img",{attrs:{src:a(1107),alt:"img"}})]),t._v(" "),_("p",[t._v("大概的原理是，"),_("strong",[t._v("首先需要一个主应用（容器应用），需要先注册子应用，然后当url匹配到相应的子应用路由后，将会先请求子应用的资源，然后挂载子应用")]),t._v("，同理，当url切换出该子应用路由时，将卸载该应用，以此达到切换子应用的效果，通过子应用生命周期boostrap（获取输出的资源文件） 、 mount、unmount的交替")]),t._v(" "),_("p",[t._v("聊聊Single-SPA 的优点：")]),t._v(" "),_("ul",[_("li",[t._v("各项目独立开发、部署、迭代，互不影响效率高")]),t._v(" "),_("li",[t._v("开发团队可以选择自己的技术并及时更新技术栈。")]),t._v(" "),_("li",[t._v("相互之间的依赖性大大降低")]),t._v(" "),_("li",[t._v("有利于CI/CD,更快的交付产品")])]),t._v(" "),_("h2",{attrs:{id:"qiankun"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#qiankun"}},[t._v("#")]),t._v(" Qiankun")]),t._v(" "),_("blockquote",[_("p",[t._v("qiankun 是一个基于 single-spa 的微前端实现库，旨在帮助大家能更简单、无痛的构建一个生产可用微前端架构系统；")])]),t._v(" "),_("h2",{attrs:{id:"参考链接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考链接"}},[t._v("#")]),t._v(" 参考链接")])])}),[],!1,null,null,null);v.default=s.exports}}]);