(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{1375:function(v,_,s){v.exports=s.p+"assets/img/10-52-15.4d3d14bc.jpg"},1376:function(v,_,s){v.exports=s.p+"assets/img/10-52-43.8ec609c8.jpg"},1377:function(v,_,s){v.exports=s.p+"assets/img/18-06-08.46ab103e.jpg"},1378:function(v,_,s){v.exports=s.p+"assets/img/18-11-42.a77536ee.jpg"},1379:function(v,_,s){v.exports=s.p+"assets/img/18-15-26.eb4ae3d2.jpg"},2173:function(v,_,s){"use strict";s.r(_);var e=s(14),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h3",{attrs:{id:"持久化分类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#持久化分类"}},[v._v("#")]),v._v(" 持久化分类")]),v._v(" "),e("blockquote",[e("p",[v._v("Redis 为了内部数据的安全考虑，会把本身的数据以文件的形式保存到硬盘中一份，在服务器重启后会自动把硬盘的数据恢复到内存(Redis)里面")])]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("RDB 持久化")]),v._v("(默认)："),e("code",[v._v("原理")]),v._v("是将 Reids 在内存中的数据库记录"),e("em",[v._v("定时 dump 到磁盘上的 RDB 持久化")]),v._v("。")]),v._v(" "),e("li",[e("strong",[v._v("AOF（append only file）持久化")]),v._v("："),e("code",[v._v("原理")]),v._v("是"),e("strong",[v._v("将 Redis 的操作日志以追加的方式写入文件")]),v._v("。开启 "),e("code",[v._v("AOF")]),v._v(" 持久化(redis.conf): "),e("strong",[v._v("appendonly yes")])])]),v._v(" "),e("p",[e("em",[v._v("RDB持久化")]),v._v("可以手动执行，也可以配置定期执行，可以把某个时间的数据状态保存到RDB文件中，反之，我们可以用RDB文件还原数据库状态。")]),v._v(" "),e("p",[e("em",[v._v("AOF持久化")]),v._v("是通过保存服务器执行的命令来记录状态的。还原的时候再执行一遍即可。")]),v._v(" "),e("h4",{attrs:{id:"两者的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两者的区别"}},[v._v("#")]),v._v(" 两者的区别：")]),v._v(" "),e("p",[v._v("RDB 持久化是指在"),e("strong",[v._v("指定的时间间隔内")]),v._v("将内存中的数据集快照写入磁盘，"),e("strong",[e("em",[v._v("实际操作过程是 fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储")]),v._v("。")]),v._v("\nAOF 持久化以日志的形式记录服务器所处理的每一个写、删除操作，"),e("strong",[v._v("查询操作不会记录，以文本的方式记录")]),v._v("，服务器"),e("code",[v._v("重启")]),v._v("的时候会**"),e("code",[v._v("重新执行")]),v._v("这些命令来"),e("code",[v._v("恢复")]),v._v("**原始的数据，可以打开文件看到详细的操作记录。\n"),e("img",{attrs:{src:s(1375),alt:""}}),v._v(" "),e("img",{attrs:{src:s(1376),alt:""}})]),v._v(" "),e("h4",{attrs:{id:"优缺点比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优缺点比较"}},[v._v("#")]),v._v(" 优缺点比较:")]),v._v(" "),e("p",[e("strong",[v._v("RDB 优点")])]),v._v(" "),e("ol",[e("li",[v._v("RDB 是"),e("strong",[v._v("紧凑的二进制文件，比较合适备份，全量复制等场景")]),v._v("；")]),v._v(" "),e("li",[v._v("RDB 恢复数据远快于 AOF。")])]),v._v(" "),e("p",[e("strong",[v._v("缺点")])]),v._v(" "),e("ol",[e("li",[v._v("RDB "),e("strong",[v._v("无法实现实时或者秒级持久化")]),v._v("；")]),v._v(" "),e("li",[v._v("新老版本无法兼容 RDB 格式。")])]),v._v(" "),e("p",[e("strong",[v._v("AOF 优点")])]),v._v(" "),e("ol",[e("li",[e("em",[v._v("可以更好地保护数据不丢失")]),v._v("；")]),v._v(" "),e("li",[v._v("appen-only 模式写入性能比较高；")]),v._v(" "),e("li",[v._v("适合做灾难性的误删除紧急恢复。")])]),v._v(" "),e("p",[e("strong",[v._v("缺点：")])]),v._v(" "),e("ol",[e("li",[v._v("对于同一份文件，AOF 文件要比 RDB 快照大；")]),v._v(" "),e("li",[v._v("AOF 开启后，写的 QPS 会有所影响，相对于 RDB 来说 写 QPS 要下降；")]),v._v(" "),e("li",[e("em",[v._v("数据库恢复比较慢， 不合适做冷备")]),v._v("。")])]),v._v(" "),e("h4",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),e("ul",[e("li",[v._v("如果你对"),e("code",[v._v("数据安全性非常重视")]),v._v("的话，你应该同时使用"),e("code",[v._v("两种持久化")]),v._v("功能")]),v._v(" "),e("li",[v._v("如果你承受"),e("code",[v._v("数分钟以内的数据丢失")]),v._v("，你可以只使用 "),e("code",[v._v("RDB 持久化")])])]),v._v(" "),e("p",[v._v("二者选择的标准，就是看是否愿意牺牲"),e("code",[v._v("一些性能")]),v._v("，换取更高的"),e("code",[v._v("缓存一致性")]),v._v("（AOF），还是愿意"),e("code",[v._v("写")]),v._v("操作"),e("code",[v._v("频繁")]),v._v("的时候，"),e("code",[v._v("不启用备份")]),v._v("来换取"),e("code",[v._v("更高的性能")]),v._v("，待手动运行 "),e("code",[v._v("save")]),v._v(" 的时候，再做备份（RDB）。\n"),e("code",[v._v("注：")]),v._v(" 未来 "),e("code",[v._v("Redis")]),v._v(" 可能会将 "),e("code",[v._v("AOF")]),v._v(" 和 "),e("code",[v._v("RDB")]),v._v(" 整合成"),e("code",[v._v("单个持久化模型")]),v._v(".")]),v._v(" "),e("p",[v._v("RDB和AOF如何选择")]),v._v(" "),e("p",[v._v("（1）不要仅仅使用RDB，因为那样会让你丢失很多的数据")]),v._v(" "),e("p",[v._v("（2）也不要仅仅使用AOF，因为RDB做冷备份数据更快，恢复数据也更快，而且bug更少")]),v._v(" "),e("p",[v._v("（3）"),e("strong",[v._v("综合使用AOF和RDB两种备份数据")])]),v._v(" "),e("hr"),v._v(" "),e("h3",{attrs:{id:"缓存的更新策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存的更新策略"}},[v._v("#")]),v._v(" 缓存的更新策略")]),v._v(" "),e("p",[v._v("缓存的更新策略包含:")]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("先更新数据库，再更新缓存")])]),v._v(" "),e("li",[e("strong",[v._v("先删除缓存，再更新数据库")])]),v._v(" "),e("li",[e("strong",[v._v("先更新数据库，再删除缓存")])])]),v._v(" "),e("p",[e("strong",[v._v("策略一：先更新数据库，再更新缓存")])]),v._v(" "),e("ol",[e("li",[v._v("这种策略会导致线程安全问题")])]),v._v(" "),e("p",[v._v("例如：线程 1 更新了数据库，线程 2 也更新数据库， 这时候由于某种原因，线程 2 首先更新了缓存，线程 1 后续更新。 这样就导致了脏数据的问题。 因为目前数据库中存储的线程 2 更新后的数据，而缓存存储的是线程1更新的老数据。")]),v._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[v._v("更新缓存的复杂度相对较高")])]),v._v(" "),e("p",[v._v("数据写入数据库之后，一般存入缓存的数据都要经过一系列的加工计算，然后写入缓存。 这时候更新缓存相比较于直接删除缓存要比较复杂。")]),v._v(" "),e("p",[e("strong",[v._v("策略二：先删除缓存，再更新数据库")])]),v._v(" "),e("p",[v._v("这种策略"),e("strong",[v._v("可能导致数据不一致的问题")]),v._v("。线程 1 写数据删除缓存；这时候有线程 2 查询该缓存，发现不存在，则去访问数据库，得到旧值放入缓存；线程 1 更新数据库。这时候就出现了数据不一致的问题。 如果缓存没有过期时间，这个脏数据一直存在。")]),v._v(" "),e("p",[v._v("解决方案："),e("em",[e("strong",[v._v("在写数据库成功之后， 再次淘汰缓存一次")])]),v._v("。")]),v._v(" "),e("p",[e("strong",[v._v("策略三：先更新数据库，再删除缓存")])]),v._v(" "),e("p",[v._v("可能会造成比较短暂的数据不一致。在更新完成数据库， 还没有删除缓存的时刻，如果有缓存数据访问， 就会造成数据不一致的情形。 "),e("strong",[v._v("但这种如果数据同步机制比较科学，一般都会比较快， 不一致的影响比较小。")])]),v._v(" "),e("h3",{attrs:{id:"缓存常见异常及解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存常见异常及解决方案"}},[v._v("#")]),v._v(" 缓存常见异常及解决方案")]),v._v(" "),e("p",[v._v("缓存使用过程当中，我们经常遇到的一些问题总结有四点：")]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("缓存穿透")])]),v._v(" "),e("li",[e("strong",[v._v("缓存雪崩")]),v._v("\n3. "),e("strong",[v._v("缓存预热")]),v._v("\n2. "),e("strong",[v._v("缓存降级")])])]),v._v(" "),e("h4",{attrs:{id:"缓存穿透"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[v._v("#")]),v._v(" 缓存穿透")]),v._v(" "),e("p",[v._v("一般访问缓存的流程，如果缓存中存在查询的商品数据，那么直接返回。 如果缓存中不存在商品数据， 就要访问数据库。\n由于不恰当的业务功能实现，或者外部恶意攻击不断地请求某些不存在的数据内存，由于缓存中没有保存该数据，导致所有的请求都会落到数据库上，对数据库可能带来一定的压力，甚至崩溃。\n"),e("img",{attrs:{src:s(1377),alt:""}}),v._v(" "),e("strong",[v._v("解决方案：")])]),v._v(" "),e("p",[v._v("针对缓存穿透的情况， 简单的对策就是"),e("strong",[v._v("将不存在的数据访问结果， 也存储到缓存中，避免缓存访问的穿透")]),v._v("。最终不存在商品数据的访问结果也缓存下来。有效的避免缓存穿透的风险。")]),v._v(" "),e("h4",{attrs:{id:"缓存雪崩"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[v._v("#")]),v._v(" 缓存雪崩")]),v._v(" "),e("p",[e("code",[v._v("当缓存重启或者大量的缓存在某一时间段失效")]),v._v("， 这样就导致大批流量直接访问数据库， 对 DB 造成压力， 从而引起 DB 故障，系统崩溃。")]),v._v(" "),e("p",[v._v("举例来说， 我们在准备一项抢购的促销运营活动，活动期间将带来大量的商品信息、库存等相关信息的查询。 为了避免商品数据库的压力，将商品数据放入缓存中存储。 "),e("code",[v._v("不巧的是，抢购活动期间，大量的热门商品缓存同时失效过期了，导致很大的查询流量落到了数据库之上。对于数据库来说造成很大的压力")]),v._v("。")]),v._v(" "),e("p",[e("strong",[v._v("解决方案：")])]),v._v(" "),e("ol",[e("li",[v._v("将商品"),e("code",[v._v("根据品类热度分类， 购买比较多的类目商品缓存周期长一些")]),v._v("， 购买相对冷门的类目商品，缓存周期短一些；")]),v._v(" "),e("li",[v._v("在"),e("code",[v._v("设置商品具体的缓存生效时间的时候， 加上一个随机的区间因子")]),v._v("， 比如说 5~10 分钟之间来随意选择失效时间；")]),v._v(" "),e("li",[e("code",[v._v("提前预估 DB 能力")]),v._v("， 如果缓存挂掉，数据库仍可以在一定程度上抗住流量的压力")])]),v._v(" "),e("p",[v._v("这三个策略能够有效的避免短时间内，大批量的缓存失效的问题。")]),v._v(" "),e("h4",{attrs:{id:"缓存击穿"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿"}},[v._v("#")]),v._v(" 缓存击穿")]),v._v(" "),e("blockquote",[e("p",[v._v("是针对缓存中没有但数据库有的数据。")]),v._v(" "),e("p",[v._v("场景是，当Key失效后，假如瞬间突然涌入大量的请求，来请求同一个Key，这些请求不会命中Redis，都会请求到DB，导致数据库压力过大，甚至扛不住，挂掉。")])]),v._v(" "),e("p",[e("strong",[v._v("解决方案:")])]),v._v(" "),e("p",[v._v("1、设置热点Key，自动检测热点Key，将热点Key的过期时间加大或者设置为永不过期，或者设置为逻辑上永不过期")]),v._v(" "),e("p",[v._v("2、加互斥锁。当发现没有命中Redis，"),e("strong",[v._v("去查数据库的时候，在执行更新缓存的操作上加锁")]),v._v("，当一个线程访问时，其它线程等待，这个线程访问过后，缓存中的数据会被重建，这样其他线程就可以从缓存中取值。")]),v._v(" "),e("h4",{attrs:{id:"缓存预热"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存预热"}},[v._v("#")]),v._v(" 缓存预热")]),v._v(" "),e("p",[v._v("缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。"),e("code",[v._v("用户直接查询事先被预热的缓存数据")]),v._v("。\n如果不进行预热， 那么 Redis 初识状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。\n如图所示：\n"),e("img",{attrs:{src:s(1378),alt:""}}),v._v(" "),e("strong",[v._v("解决方案：")])]),v._v(" "),e("ol",[e("li",[e("em",[v._v("数据量不大的时候")]),v._v("，"),e("strong",[v._v("工程启动的时候进行加载缓存动作")]),v._v("；")]),v._v(" "),e("li",[e("em",[v._v("数据量大的时候")]),v._v("，"),e("strong",[v._v("设置一个定时任务脚本，进行缓存的刷新")]),v._v("；")]),v._v(" "),e("li",[e("em",[v._v("数据量太大的时候")]),v._v("，"),e("strong",[v._v("优先保证热点数据进行提前加载到缓存")]),v._v("。")])]),v._v(" "),e("h4",{attrs:{id:"缓存降级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存降级"}},[v._v("#")]),v._v(" 缓存降级")]),v._v(" "),e("p",[v._v("降级的情况，"),e("em",[v._v("就是缓存失效或者缓存服务挂掉的情况下，我们也不去访问数据库")]),v._v("。我们直接访问内存部分数据缓存或者直接返回默认数据。\n举例来说：")]),v._v(" "),e("blockquote",[e("p",[v._v("对于应用的首页，一般是访问量非常大的地方，首页里面往往包含了部分推荐商品的展示信息。这些推荐商品都会放到缓存中进行存储，"),e("strong",[v._v("同时我们为了避免缓存的异常情况，对热点商品数据也存储到了内存中。同时内存中还保留了一些默认的商品信息")]),v._v("。")])]),v._v(" "),e("p",[v._v("降级一般是"),e("code",[v._v("有损的操作，所以尽量减少降级对于业务的影响程度")]),v._v("。\n如下图所示：\n"),e("img",{attrs:{src:s(1379),alt:""}})]),v._v(" "),e("h3",{attrs:{id:"重点情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重点情况"}},[v._v("#")]),v._v(" 重点情况")]),v._v(" "),e("h4",{attrs:{id:"缓存穿透及解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透及解决方案"}},[v._v("#")]),v._v(" 缓存穿透及解决方案")]),v._v(" "),e("p",[v._v("缓存穿透是指"),e("code",[v._v("缓存中查询一个不存在的数据，需要去数据库中获取")]),v._v("。")]),v._v(" "),e("p",[v._v("如果数据库也查不到结果，将不会同步到缓存，导致这个不存在数据每次请求都要到数据库查询，失去了缓存的意义。")]),v._v(" "),e("p",[v._v("解决方法有两个：")]),v._v(" "),e("p",[e("strong",[v._v("1. 布隆过滤（Bloom filter）")]),v._v(" "),e("code",[v._v("将所有查询的参数都存储到一个 bitmap 中，在查询缓存之前，先再找个 bitmap 里面进行验证。")])]),v._v(" "),e("p",[v._v("如果 bitmap 中存在，则进行底层缓存的数据查询； 如果 bitmap 中不存在查询参数，则进行拦截，不再进行缓存的数据查询。")]),v._v(" "),e("p",[e("em",[v._v("适用范围")]),v._v("：可以用来实现数据字典，进行数据的判重，或者集合求交集")]),v._v(" "),e("p",[e("strong",[v._v("2. 缓存空对象")]),v._v(" "),e("code",[v._v("如果查询返回的数据为空，仍然把这个空结果进行缓存。")]),v._v("那么再次用相同 key 获取数据的时候，即使不存在的数据，缓存也可以直接返回空值，避免重复访问 DB。")]),v._v(" "),e("p",[v._v("缓存空对象有"),e("code",[v._v("两个不足之处")]),v._v("：")]),v._v(" "),e("ol",[e("li",[v._v("缓存层将存储更多的键值对，如果是恶意的随机访问，将造成很多内存空间的浪费。"),e("code",[v._v("这个不足之处可以通过将这类数据设置很短的过期时间来控制")]),v._v("。")]),v._v(" "),e("li",[v._v("DB 与缓存数据不一致。"),e("code",[v._v("这种可以考虑通过异步消息来进行数据更新的通知，在一定程度上减少这类不一致的时间。")])])]),v._v(" "),e("p",[e("strong",[v._v("3. 以上总括")])]),v._v(" "),e("p",[v._v("1：对查询结果为空的情况也进行缓存，这样，再次访问时，缓存层会直接返回空值。缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。")]),v._v(" "),e("p",[v._v("2：对一定不存在的key进行过滤。具体请看布隆过滤器")]),v._v(" "),e("h4",{attrs:{id:"缓存雪崩及解决方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩及解决方案"}},[v._v("#")]),v._v(" 缓存雪崩及解决方案")]),v._v(" "),e("p",[e("code",[v._v("在集中的一段时间内，有大量的缓存失效")]),v._v("，导致大量的访问没有命中缓存，从而将所有查询进行数据库访问，导致数据库的压力增大，从而造成了缓存雪崩。")]),v._v(" "),e("p",[v._v("比如，如果要做一个促销活动，我们将商品信息都刷新到缓存， 过期时间统一为 30 分钟。那么在 30 分钟之后，这批商品将全部过期。这时候这批商品的访问查询，都落到了数据库，对于数据库而言，这一刻的压力会非常大。从而造成系统整体性风险。")]),v._v(" "),e("p",[v._v("解决方案：")]),v._v(" "),e("p",[e("strong",[v._v("方法 1：分散失效时间")])]),v._v(" "),e("p",[v._v("分析缓存数据的特点，"),e("em",[v._v("尽量将热点缓存的失效时间均匀分布")]),v._v("。 比如说将相同类型的缓存的失效时间设置成一个在一定区间内的随机值。从而有效的分散失效时间。让Key的失效时间分散开，可以在统一的失效时间上再加一个随机值，或者使用更高级的算法分散失效时间。")]),v._v(" "),e("p",[e("strong",[v._v("方法 2：DB 访问限制")])]),v._v(" "),e("p",[v._v("对数据的访问进行限流性质的操作。比如说"),e("code",[v._v("对数据库访问进行加锁的处理或者限流相关的处理")]),v._v("。对存储层增加限流措施，当请求超出限制，提供降级服务（一般就是返回错误即可）")]),v._v(" "),e("p",[e("strong",[v._v("方法 3：多级缓存设计")])]),v._v(" "),e("p",[v._v("一级缓存为基础缓存，缓存失效时间设置一个较长时间， 二级缓存为应用缓存，失效时间正常设置，一般会比较短。 **当二级缓存失效的时候，再从一级缓存里面获取。**多级缓存：比如增加本地缓存，减小redis压力。")]),v._v(" "),e("p",[e("strong",[v._v("方法4：构建多个redis实例")])]),v._v(" "),e("p",[v._v("个别节点挂了还有别的可以用。")]),v._v(" "),e("hr"),v._v(" "),e("h3",{attrs:{id:"淘汰策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#淘汰策略"}},[v._v("#")]),v._v(" 淘汰策略")]),v._v(" "),e("h4",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[v._v("#")]),v._v(" 简介")]),v._v(" "),e("p",[v._v("redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。")]),v._v(" "),e("p",[v._v("Redis 可以看作是一个内存数据库，通过 Maxmemory 指令配置 Redis 的数据集使用指定量的内存。设置 Maxmemory 为 0，则表示无限制。")]),v._v(" "),e("p",[v._v("当内存使用达到 Maxmemory 极限时，需要使用某种淘汰算法来决定清理掉哪些数据，以保证新数据的存入。")]),v._v(" "),e("h4",{attrs:{id:"redis-提供-6种数据淘汰策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-提供-6种数据淘汰策略"}},[v._v("#")]),v._v(" redis 提供 6种数据淘汰策略：")]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("no-enviction（驱逐）")]),v._v("：禁止驱逐数据; 当内存使用达到上限，所有需要申请内存的命令都会异常报错。")]),v._v(" "),e("li",[e("strong",[v._v("volatile-lru")]),v._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰;淘汰一部分最近使用较少的（LRC），但只限于过期设置键。")]),v._v(" "),e("li",[e("strong",[v._v("volatile-ttl")]),v._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰; 优先移除具有更早失效时间的 key。")]),v._v(" "),e("li",[e("strong",[v._v("volatile-random")]),v._v("：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰; 随机淘汰某一个键。")]),v._v(" "),e("li",[e("strong",[v._v("allkeys-lru")]),v._v("：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰;  先试图移除一部分最近未使用的 key。")]),v._v(" "),e("li",[e("strong",[v._v("allkeys-random")]),v._v("：从数据集（server.db[i].dict）中任意选择数据淘汰;   随机淘汰某一个键。")])]),v._v(" "),e("h4",{attrs:{id:"常见的淘汰算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的淘汰算法"}},[v._v("#")]),v._v(" 常见的淘汰算法")]),v._v(" "),e("ul",[e("li",[e("p",[e("strong",[v._v("FIFO：First In First Out")])]),v._v(" "),e("p",[e("strong",[v._v("先进先出")]),v._v("。判断被存储的时间，离目前最远的数据优先被淘汰。")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("LRU：Least Recently Used")])]),v._v(" "),e("p",[e("strong",[v._v("最近最少使用")]),v._v("。判断最近被使用的时间，目前最远的数据优先被淘汰。")])]),v._v(" "),e("li",[e("p",[e("strong",[v._v("LFU：Least Frequently Used")])]),v._v(" "),e("p",[e("strong",[v._v("最不经常使用")]),v._v("。在一段时间内，数据被使用次数最少的，优先被淘汰。")])])]),v._v(" "),e("h4",{attrs:{id:"lru的具体实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lru的具体实现"}},[v._v("#")]),v._v(" LRU的具体实现")]),v._v(" "),e("p",[v._v("LRU全称是Least Recently Used，即最近最久未使用的意思。")]),v._v(" "),e("p",[v._v("LRU算法的设计原则是："),e("strong",[v._v("如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小")]),v._v("。"),e("code",[v._v("也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰")]),v._v("。")]),v._v(" "),e("p",[v._v("redis"),e("code",[v._v("原始的淘汰算法简单实现")]),v._v("：当需要淘汰一个key时，随机选择3个key，淘汰其中间隔时间最长的key。**基本上，我们随机选择key，淘汰key效果很好。"),e("code",[v._v('后来随机3个key改成一个配置项"N随机key"')]),v._v("。但把默认值提高改成5个后效果大大提高。考虑到它的效果，你根本不用修改他。")]),v._v(" "),e("hr"),v._v(" "),e("h3",{attrs:{id:"缓存失效策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存失效策略"}},[v._v("#")]),v._v(" 缓存失效策略")]),v._v(" "),e("p",[v._v("策略有："),e("code",[v._v("定时删除策略")]),v._v("，"),e("code",[v._v("惰性删除策略")]),v._v("，"),e("code",[v._v("定期删除策略")]),v._v("。")]),v._v(" "),e("p",[e("strong",[v._v("定时删除策略")])]),v._v(" "),e("p",[v._v("在设置 key 的过期时间的同时，为该 key 创建一个定时器，让定时器在 key 的过期时间来临时，对 key 进行删除。")]),v._v(" "),e("ul",[e("li",[v._v("优点：保证内存尽快释放。")]),v._v(" "),e("li",[v._v("缺点：若 key 过多，删除这些 key 会占用很多 CPU 时间， 而且每个 key 创建一个定时器，性能影响严重。")])]),v._v(" "),e("p",[e("strong",[v._v("惰性删除策略")])]),v._v(" "),e("p",[v._v("key 过期的时候不删除，每次从数据库获取 key 的时候去检查是否过期，若过期，则删除，返回 null。")]),v._v(" "),e("ul",[e("li",[v._v("优点：CPU 时间占用比较少。")]),v._v(" "),e("li",[v._v("缺点：若 key 很长时间没有被获取， 将不会被删除，可能造成内存泄露。")])]),v._v(" "),e("p",[e("strong",[v._v("定期删除策略")])]),v._v(" "),e("p",[v._v("每隔一段时间执行一次删除（在 redis.conf 配置文件设置 hz，1s 刷新的频率）过期 key 操作。")]),v._v(" "),e("ul",[e("li",[v._v("优点：可以控制删除操作的时长和频率，来减少 CPU 时间占用，可以避免惰性删除时候内存泄漏的问题。")]),v._v(" "),e("li",[v._v("缺点：对内存友好方面，不如定时策略；对 CPU 友好方面，不如惰性策略")])]),v._v(" "),e("p",[e("strong",[v._v("Redis 一般采用："),e("code",[v._v("惰性策略 + 定期策略")]),v._v("两个相结合。")])]),v._v(" "),e("h3",{attrs:{id:"缓存命中率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存命中率"}},[v._v("#")]),v._v(" 缓存命中率")]),v._v(" "),e("h4",{attrs:{id:"缓存命中率简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存命中率简介"}},[v._v("#")]),v._v(" 缓存命中率简介")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("命中：")]),e("code",[v._v("可以直接通过缓存获取到需要的数据")]),v._v("。")]),v._v(" "),e("li",[v._v("**不命中：**无法直接通过缓存获取到想要的数据，需要再次查询数据库或者其他数据存储载体的操作。原因"),e("code",[v._v("可能是由于缓存中根本不存在，或者缓存已经过期。")])])]),v._v(" "),e("blockquote",[e("p",[e("strong",[v._v("缓存命中率 = 缓存中获取数据次数/获取数据总次数")])])]),v._v(" "),e("p",[v._v("通常来说，缓存命中率越高，缓存的收益越高，应用的性能也就越好。表示使用缓存作用越好，性能越高（"),e("code",[v._v("响应时间越短、吞吐量越高")]),v._v("），并发能力也越好。")]),v._v(" "),e("h4",{attrs:{id:"提高缓存命中率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提高缓存命中率"}},[v._v("#")]),v._v(" 提高缓存命中率")]),v._v(" "),e("p",[e("strong",[v._v("重点关注访问频率高且时效性相对低一些的业务数据上")]),v._v("，利用"),e("code",[v._v("预加载（预热）、扩容、优化缓存粒度、更新缓存等")]),v._v("手段来提高命中率。")]),v._v(" "),e("p",[v._v("通常的手段有：")]),v._v(" "),e("ol",[e("li",[e("strong",[v._v("缓存预加载")])]),v._v(" "),e("li",[e("strong",[v._v("增加缓存存储量")])]),v._v(" "),e("li",[e("strong",[v._v("调整缓存存储数据类型")])]),v._v(" "),e("li",[e("strong",[v._v("提升缓存更新频次")])])]),v._v(" "),e("h3",{attrs:{id:"案例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#案例"}},[v._v("#")]),v._v(" 案例")]),v._v(" "),e("p",[e("strong",[v._v("场景")]),v._v("：数据库中有1000w的数据，而redis中只有50w数据，如何保证redis中10w数据都是热点数据？")]),v._v(" "),e("p",[e("strong",[v._v("方案")]),v._v("：限定 Redis 占用的内存，"),e("strong",[v._v("Redis 会根据自身数据淘汰策略，留下热数据到内存")]),v._v("。所以，计算一下 50W 数据大约占用的内存，然后"),e("code",[v._v("设置一下 Redis 内存限制")]),v._v("即可，"),e("code",[v._v("并将淘汰策略为volatile-lru或者allkeys-lru")]),v._v("。")]),v._v(" "),e("p",[v._v("设置Redis最大占用内存：打开redis配置文件，设置maxmemory参数，maxmemory是bytes字节类型")]),v._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("# In short... if you have slaves attached it is suggested that you set a lower\n# limit for maxmemory so that there is some free RAM on the system for slave\n# output buffers (but this is not needed if the policy is 'noeviction').\n#\n# maxmemory <bytes>\nmaxmemory 268435456\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br"),e("span",{staticClass:"line-number"},[v._v("2")]),e("br"),e("span",{staticClass:"line-number"},[v._v("3")]),e("br"),e("span",{staticClass:"line-number"},[v._v("4")]),e("br"),e("span",{staticClass:"line-number"},[v._v("5")]),e("br"),e("span",{staticClass:"line-number"},[v._v("6")]),e("br")])]),e("p",[v._v("设置过期策略：")]),v._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[v._v("maxmemory-policy volatile-lru\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br")])]),e("hr"),v._v(" "),e("h3",{attrs:{id:"问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[v._v("#")]),v._v(" 问题")]),v._v(" "),e("p",[e("strong",[v._v("如果 AOF 文件的数据出现异常， Redis 服务怎么处理？")])]),v._v(" "),e("p",[v._v("如果 AOF 文件出现异常， Redis 在重启的时候将会拒绝加载 AOF 文件，从而保证数据的一致性。这时候，"),e("strong",[v._v("可以试着对 AOF 文件进行修复")]),v._v("："),e("code",[v._v("redis-check-aof -fix")]),v._v("。")]),v._v(" "),e("p",[e("strong",[v._v("MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据")]),v._v("?")]),v._v(" "),e("p",[v._v("Redis 内存数据集大小上升到一定大小的时候， 就会施行数据淘汰策略")]),v._v(" "),e("p",[e("strong",[v._v("Redis 的内存用完了会发生什么？")])]),v._v(" "),e("p",[v._v("如果达到设置的上限， "),e("em",[v._v("Redis 的写命令会返回错误信息（但是读命令还可以正常返回）")]),v._v(" 或者你可以"),e("strong",[v._v("将 Redis 当缓存来使用配置淘汰机制")]),v._v("，当 Redis 达到内存上限时会冲刷掉旧的内容。")]),v._v(" "),e("p",[e("strong",[v._v("为什么不用定时删除策略?")])]),v._v(" "),e("p",[v._v("定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。"),e("em",[v._v("在大并发请求下，CPU要将时间应用在处理请求，而不是删除key")]),v._v(",因此没有采用这一策略.")]),v._v(" "),e("p",[e("strong",[v._v("定期删除+惰性删除是如何工作的呢?")])]),v._v(" "),e("p",[v._v("定期删除，"),e("strong",[v._v("redis默认每个100ms检查")]),v._v("，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。\n于是，"),e("strong",[v._v("惰性删除派上用场")]),v._v("。也就是说在你"),e("strong",[v._v("获取某个key的时候，redis会检查一下")]),v._v("，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。")])])}),[],!1,null,null,null);_.default=t.exports}}]);